<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Powerful Backend 组件理解</title>
    <url>/powerful-backend-components/</url>
    <content><![CDATA[<p>理解 Nginx, Redis, RabbitMQ, MySQL 各部分组件 </p>
<a id="more"></a>

<p>Flask </p>
<p>缓存层 Redis</p>
<p>消息队列 RabbitMQ 异步执行</p>
<p>Data Fetcher 从数据库取数据</p>
<p>Locust Python负载均衡 10x</p>
<hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ol>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
<h3 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h3><ol>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ol>
<p>【总之就是一个高性能的存储】</p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p>
<p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p>
<p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p>
<ol>
<li>可靠性（Reliability） RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li>
<li>消息集群（Clustering） 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li>
<li>高可用（Highly Available Queues） 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
<li>多种协议（Multi-protocol） RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li>
<li>管理界面（Management UI） RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li>
<li>跟踪机制（Tracing） 如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li>
<li>插件机制（Plugin System） RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<p>【就是一个消息队列】</p>
]]></content>
  </entry>
  <entry>
    <title>PyMuPDF 进行 PDF 处理</title>
    <url>/pymupdf-process-pdf/</url>
    <content><![CDATA[<p>PyMuPDF（fitz）：MuPDF 的 Python 绑定，它是一个轻量级的 PDF 和 XPS 查看器。该库可以访问 PDF，XPS，OpenXPS，epub，漫画和小说书籍格式的文件，并以其顶级性能和高渲染质量而闻名。</p>
<p><a href="https://github.com/pymupdf/PyMuPDF/wiki" target="_blank" rel="noopener">PyMuPDF/wiki</a></p>
<p><img data-src="/pymupdf-process-pdf/13717038-cdc4983066bc598f.webp" alt="img"></p>
<h3 id="使用-PyMuPDF-从-PDF-中提取图像"><a href="#使用-PyMuPDF-从-PDF-中提取图像" class="headerlink" title="使用 PyMuPDF 从 PDF 中提取图像"></a>使用 PyMuPDF 从 PDF 中提取图像</h3><p>PyMuPDF 使用 getPageImageList（）方法简化了从 PDF 文档中提取图像的过程。下面的代码来源于 PyMuPDF wiki 页面的示例，并逐页提取并保存 PDF 中的所有图像作为 PNG 文件。 如果图像具有 CMYK 颜色空间，则首先将其转换为 RGB。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>overleaf写汉语报告</title>
    <url>/overleaf-chinese/</url>
    <content><![CDATA[<p>在 overleaf <a href="https://www.overleaf.com/learn/latex/chinese" target="_blank" rel="noopener">官网文档</a>，已经详细说明了配置，这里简单概括一下。</p>
<p>就是在最开始添加 <code>ctex</code> 包就可以啦！</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span></span> &#123;ctex&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>np.unique( )的用法</title>
    <url>/np-unique/</url>
    <content><![CDATA[<p>去除数组中的重复数字，并进行排序之后输出。</p>
<p>要求是 <code>arr</code> 里面是相同的维数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">result1 = np.unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">print(type(result1))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line">print(result1)  <span class="comment"># [1 2 3 4]</span></span><br><span class="line"></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">result2 = np.unique(arr)</span><br><span class="line">print(type(result2))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line">print(result2)  <span class="comment"># [1 2 3]</span></span><br><span class="line"></span><br><span class="line">arr = np.array([[<span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">4</span>]])</span><br><span class="line">result3 = np.unique(arr)</span><br><span class="line">print(type(result3))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line">print(result3)  <span class="comment"># [3 4 5 7 8]</span></span><br></pre></td></tr></table></figure>

<p>如果使用不同的维数：</p>
<p>依旧是排序，但是排序的对象就不同了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>]])</span><br><span class="line">result3 = np.unique(arr)</span><br><span class="line">print(type(result3))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line">print(result3)  <span class="comment"># [list([3, 3]) list([5, 4, 9, 0]) list([7, 8])]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>latex模板研究</title>
    <url>/latex-configuration/</url>
    <content><![CDATA[<p>最近在配置的我的简历模板，正好研究一下 LaTex 相关的命令。</p>
<a id="more"></a>

<h3 id="命令替换-newcommand"><a href="#命令替换-newcommand" class="headerlink" title="命令替换 \newcommand"></a>命令替换 \newcommand</h3><p>自定义一个新的命令来替换一段代码</p>
<p>简洁的表示语法，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\newcommand&#123;\新定义的命令&#125;[参数个数]&#123;命令内容&#125;      %  或者如下</span><br><span class="line">\newcommand*&#123;\新定义的命令&#125;[参数个数]&#123;命令内容&#125;     % 带*的为短命令</span><br><span class="line">											   %命令内容不能出现段落，即不能有\par</span><br><span class="line">											   </span><br><span class="line">\renewcommand&#123;\新定义的命令&#125;[参数个数]&#123;命令内容&#125;    %  对原来已有的命令重新定义</span><br><span class="line">\renewcommand*&#123;\新定义的命令&#125;[参数个数]&#123;命令内容&#125;</span><br></pre></td></tr></table></figure>

<p>实际情况应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\newcommand&#123;\topcolor&#125; &#123;\arrayrulecolor&#123;tabcolor&#125;  \toprule[\mytablinewidth] &#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>\topcolor</code> 来代替 <code>\arrayrulecolor{tabcolor}  \toprule[\mytablinewidth]</code> 一系列命令。</p>
<h3 id="自定义标题-titleformat"><a href="#自定义标题-titleformat" class="headerlink" title="自定义标题 titleformat"></a>自定义标题 titleformat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\titleformat&#123;command&#125;[shape]%定义标题类型和标题样式，字体</span><br><span class="line">&#123;format&#125;%定义标题格式:字号（大小），加粗，斜体</span><br><span class="line">&#123;label&#125;%定义标题的标签，即标题的标号等</span><br><span class="line">&#123;sep&#125;%定义标题和标号之间的水平距离</span><br><span class="line">&#123;before-code&#125;%定义标题前的内容</span><br><span class="line">[after-code]%定义标题后的内容</span><br></pre></td></tr></table></figure>

<p>里面我添加了一个 <code>\bfseries</code> 这样的话使得标题加粗</p>
<p><img data-src="/latex-configuration/14174754-6055147fce403eef.png" alt="img"></p>
<h3 id="使用-Times-New-Roman-字体"><a href="#使用-Times-New-Roman-字体" class="headerlink" title="使用 Times New Roman 字体"></a>使用 Times New Roman 字体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% Times New Roman</span><br><span class="line">\usepackage&#123;times&#125;</span><br><span class="line">\usepackage&#123;mathptmx&#125;</span><br></pre></td></tr></table></figure>

<h3 id="itemize-调整参数"><a href="#itemize-调整参数" class="headerlink" title="itemize 调整参数"></a>itemize 调整参数</h3><ol>
<li><p>垂直间距</p>
<ul>
<li>topsep    列表环境与上文之间的距离</li>
<li>parsep    条目里面段落之间的距离</li>
<li>itemsep    条目之间的距离</li>
<li>partopsep   条目与下面段落的距离</li>
</ul>
</li>
<li><p>水平间距</p>
<ul>
<li>leftmargin    列表环境左边的空白长度</li>
<li>rightmargin    列表环境右边的空白长度</li>
<li>labelsep    标号与列表环境左侧的距离</li>
<li>itemindent    条目的缩进距离</li>
<li>labelwidth    标号的宽度</li>
<li>listparindent    条目下面段落的缩进距离</li>
</ul>
</li>
</ol>
<p><img data-src="/latex-configuration/20181019161030185" alt="img"></p>
<h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ol>
<li><p><code>\vspace</code></p>
<p>编写 LaTex 文档的时候产生一个垂直的距离。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\vspace&#123;1cm&#125;;</span><br></pre></td></tr></table></figure>

<p> 在命令出现的当前行输出完后，才生成垂直间距；生成间距后，继续之前段落的内容</p>
</li>
<li><p><code>\*shape</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%shape 是字体家族</span><br><span class="line">\upshape：直立 </span><br><span class="line">\itshape：意大利斜体 </span><br><span class="line">\slshape：斜体 </span><br><span class="line">\scshape：小体大写</span><br></pre></td></tr></table></figure>

<p><img data-src="/latex-configuration/14174754-f4e9e7bf8e0d07b2.png" alt="img"></p>
</li>
<li><p>修改了 95 行的 <code>leftmargin=0.15in</code> 到 0</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-Round</title>
    <url>/python-round/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round( x [, n]  )</span><br></pre></td></tr></table></figure>

<ul>
<li>x – 数字表达式</li>
<li>n – 表示从小数点位数，其中 x 需要四舍五入，默认值为 0</li>
</ul>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">70.23456</span>) :  <span class="number">70</span></span><br><span class="line">round(<span class="number">56.659</span>,<span class="number">1</span>) :  <span class="number">56.7</span></span><br><span class="line">round(<span class="number">80.264</span>, <span class="number">2</span>) :  <span class="number">80.26</span></span><br><span class="line">round(<span class="number">100.000056</span>, <span class="number">3</span>) :  <span class="number">100.0</span></span><br><span class="line">round(<span class="number">-100.000056</span>, <span class="number">3</span>) :  <span class="number">-100.0</span></span><br></pre></td></tr></table></figure>

<p>但是浮点数精度会对结果有影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">2.675</span>, <span class="number">2</span>) </span><br><span class="line"><span class="number">2.67</span></span><br></pre></td></tr></table></figure>

<p><strong>按我们的想法返回结果应该是 2.68，可结果却是 2.67，为什么？</strong></p>
<p>这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 开启 80 端口</title>
    <url>/flask-port-80/</url>
    <content><![CDATA[<p><code>Flask</code> 在默认运行的时候是在 <code>5000</code> 端口处，映射到域名还需要额外输入 <code>:5000</code> 就不是很方便，所以就研究了一下如何映射到默认的 <code>80</code> 端口处。</p>
<a id="more"></a>

<p>Linux 中 <code>1024</code>  以下的端口都是需要 <code>root</code> 才能使用的。</p>
<p>在我的 aws 机器上使用 <code>sudo su</code> 就可以切换到 <code>root</code> 啦，不过就无法使用 <code>conda</code> 啦，所以继续尝试。</p>
<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport <span class="number">80</span> -j REDIRECT --to-port <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>相比之下还是端口转发讲究！</p>
]]></content>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>pyPDF2识别PDF中的图表、公式的数量</title>
    <url>/python-pdf-processing-by-pypdf2/</url>
    <content><![CDATA[<p>使用 PyPDF2 读取 PDF，通过正则表达式转换 PDF 中的图片为文字</p>
<p>PyPDF2 是一个Python 库，用于提取文档信息和内容，逐页拆分文档，合并文档，裁剪页面和添加水印。 PyPDF2 支持未加密和加密的文档。</p>
<p>代码如下</p>
<a id="more"></a>

<p>初始引入，及查找公式个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">INPUT_DIR = <span class="string">'../dataset_new/'</span></span><br><span class="line">OUTPUT_DIR = <span class="string">'../output/'</span></span><br><span class="line"></span><br><span class="line">score_d = &#123;</span><br><span class="line">    <span class="string">'='</span>: <span class="number">1.2</span>,</span><br><span class="line">    <span class="string">'('</span>: <span class="number">0.2</span>,</span><br><span class="line">    <span class="string">')'</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">'['</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">']'</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">'−'</span>: <span class="number">0.6</span>,</span><br><span class="line">    <span class="string">'+'</span>: <span class="number">1.5</span>,</span><br><span class="line">    <span class="string">'-'</span>: <span class="number">0.6</span>,</span><br><span class="line">    <span class="string">'/'</span>: <span class="number">1.5</span>,</span><br><span class="line">    <span class="string">'^'</span>: <span class="number">1.1</span>,</span><br><span class="line">    <span class="string">'|'</span>: <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">''</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">formula_pattern = re.compile(<span class="string">r'=|/|−|-|^|\||\[|\]|\+|\(\d&#123;1,2&#125;\)|\(\w\)|\('</span>)</span><br><span class="line">exclude_pattern = re.compile(<span class="string">r'\+\+|http|--|==|pdf'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_score</span><span class="params">(r)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> r:</span><br><span class="line">        <span class="keyword">if</span> len(t) &gt; <span class="number">1</span>:</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s += score_d[t]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formula_num</span><span class="params">(text)</span>:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    l = []</span><br><span class="line">    tmp = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> text.split(<span class="string">'\n'</span>):</span><br><span class="line">        <span class="keyword">if</span> len(t) &lt;= <span class="number">5</span>:</span><br><span class="line">            tmp += t</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> tmp != <span class="string">''</span>:</span><br><span class="line">                l.append(tmp)</span><br><span class="line">                tmp = <span class="string">''</span></span><br><span class="line">            l.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> l:</span><br><span class="line">        p = exclude_pattern.findall(t)</span><br><span class="line">        <span class="keyword">if</span> len(t) &gt; <span class="number">100</span> <span class="keyword">or</span> len(p) &gt; <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">        res = formula_pattern.findall(t)</span><br><span class="line">        s = cal_score(res)</span><br><span class="line">        <span class="keyword">if</span> s &gt; <span class="number">3</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pdf_meta</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pdfFileObject = open(path, <span class="string">'rb'</span>)</span><br><span class="line">        pdfReader = PyPDF2.PdfFileReader(pdfFileObject)</span><br><span class="line">        count = pdfReader.numPages</span><br><span class="line">        figures = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">        tables = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">        formulas = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">7</span>: <span class="keyword">break</span></span><br><span class="line">            page = pdfReader.getPage(i)</span><br><span class="line">            text = page.extractText()</span><br><span class="line">            <span class="comment"># figures and table</span></span><br><span class="line">            pattern = re.compile(<span class="string">r'(Figure|Table|Fig\.)\s*(\d+)(:)'</span>)</span><br><span class="line">            res = pattern.findall(text)</span><br><span class="line">            res = set([<span class="string">''</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">if</span> item.startswith(<span class="string">'Fig'</span>):</span><br><span class="line">                    figures[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tables[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># formula</span></span><br><span class="line">            formulas[i] = get_formula_num(text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.array(figures).sum() == <span class="number">0</span> <span class="keyword">and</span> np.array(tables).sum() == <span class="number">0</span>:</span><br><span class="line">            s = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">7</span>: <span class="keyword">break</span></span><br><span class="line">                page = pdfReader.getPage(i)</span><br><span class="line">                text = page.extractText()</span><br><span class="line">                pattern = re.compile(</span><br><span class="line">                    <span class="string">r'(Figure|Table|Fig\.)\s*(\d+)(\.[A-Z]&#123;0,1&#125;)'</span>)</span><br><span class="line">                res = pattern.findall(text)</span><br><span class="line">                res = set(</span><br><span class="line">                    [<span class="string">''</span>.join(i).replace(<span class="string">'.'</span>, <span class="string">':'</span>).split(<span class="string">':'</span>)[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]) - s</span><br><span class="line">                s = s | res</span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">                    <span class="keyword">if</span> item.startswith(<span class="string">'Fig'</span>):</span><br><span class="line">                        figures[i] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tables[i] += <span class="number">1</span></span><br><span class="line">        pdfFileObject.close()</span><br><span class="line">        <span class="keyword">return</span> figures, tables, formulas, count</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(path, e)</span><br><span class="line">        pdfFileObject.close()</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>], [<span class="number">-1</span>], [<span class="number">-1</span>], <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>main 函数多线程操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'execute lgb_process.py ...'</span>)</span><br><span class="line">    lgb_output = OUTPUT_DIR + <span class="string">'lgb_output/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(lgb_output):</span><br><span class="line">        os.makedirs(lgb_output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(path)</span>:</span></span><br><span class="line">        figures, tables, formulas, cnt = get_pdf_meta(path)</span><br><span class="line">        <span class="keyword">return</span> path, figures, tables, formulas, cnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">'conference'</span>, <span class="string">'workshop'</span>]:</span><br><span class="line">        lst = []</span><br><span class="line">        conf_fold = INPUT_DIR + <span class="string">'train/%s/'</span> % name</span><br><span class="line">        <span class="keyword">for</span> pdf <span class="keyword">in</span> os.listdir(conf_fold):</span><br><span class="line">            lst.append(conf_fold + pdf)</span><br><span class="line"></span><br><span class="line">        ret = Pool(<span class="number">20</span>).map(func, lst)</span><br><span class="line">        json.dump(</span><br><span class="line">            ret, open(lgb_output + <span class="string">'%s.json'</span> % name, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>),</span><br><span class="line">            			ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/re-expression/</url>
    <content><![CDATA[<p>总遇见正则的常用场景，这次就来记录一下。</p>
<p><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">网上的正则表达式手册</a></p>
<p><a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">菜鸟在线正则表达式测试</a></p>
<p>这次使用的是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'(Figure|Table|Fig\.)\s*(\d+)(:)'</span>)</span><br></pre></td></tr></table></figure>

<p>然后在文本中搜索</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = pattern.findall(text)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>更新GITHUB仓库</title>
    <url>/clear-github-repo/</url>
    <content><![CDATA[<h3 id="更新原因"><a href="#更新原因" class="headerlink" title="更新原因"></a>更新原因</h3><p>因为之前不小心上传了大文件，我的 git 文件夹中包含大量的神奇文件。</p>
<h3 id="更新诉求"><a href="#更新诉求" class="headerlink" title="更新诉求"></a>更新诉求</h3><p>我只想要保留最新的文档内容，并不在意我过去提交的历史</p>
<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>删除<code>.git</code>文件夹可能会导致git存储库中的问题。如果要删除所有提交历史记录，但将代码保持在当前状态，可以按照以下方式安全地执行此操作：</p>
<ol>
<li><code>尝试  运行  git checkout --orphan latest_branch</code></li>
<li>添加所有文件<code>git add -A</code></li>
<li>提交更改<code>git commit -am &quot;commit message&quot;</code></li>
<li>删除分支<code>git branch -D master</code></li>
<li>将当前分支重命名<code>git branch -m master</code></li>
<li>最后，强制更新存储库。<code>git push -f origin master</code></li>
</ol>
]]></content>
      <tags>
        <tag>GITHUB</tag>
      </tags>
  </entry>
  <entry>
    <title>GFS</title>
    <url>/MIT-6.824-GFS/</url>
    <content><![CDATA[<p><strong>GFS</strong> - The Google File System.</p>
<p><code>parallel performance, fault tolerance, replication, consistency</code></p>
<p><strong>Why is distributed storage hard?</strong></p>
<ul>
<li>high performance -&gt; shard data over many servers</li>
<li>many servers -&gt; constant faults</li>
<li>fault tolerance -&gt; replication</li>
<li>replication -&gt; potential inconsistencies</li>
<li>better consistency -&gt; low performance</li>
</ul>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="/MIT-6.824-GFS/4309024-3e9b3ed1e3bf65c0.webp" alt="img"></p>
<p>GFS主要包括master和chunk server两部分组成。一个文件被打散成了多个chunk，每个chunk会在多个chunk server上保存作为冗余备份。客户端向master请求某个某个文件的某个chunk的数据，master返回这个chunk所属的chunk server。客户端再请求对应的chunk server操作数据。</p>
<p><strong>几个问题：</strong></p>
<blockquote>
<p>这种数据存储形式有什么好处？</p>
</blockquote>
<p>这样的设计巧妙的解耦了元数据和数据。对于元数据，只有master知道。因此，master必须好好维护这些信息，防止数据丢失或者错误，因此写operation log就变得非常重要。而对于数据本身，chunk server更加了解自身存储的情况，因此chunk的信息，chunk server说了算。这样避免了master中持久化一份数据分布的信息而带来的与实际情况不一致的情况(另外设计一套同步机制会使系统变得复杂)。</p>
<blockquote>
<p>master机器只有一台，怎么避免单点故障？</p>
</blockquote>
<p>为防止单点故障，肯定要准备备机。一般会存在2台或者以上的shadow master。当master在本地写operation log的时候，也会让shadow master写一份。只有在全部都写成功的时候，操作才会继续。如果master的硬盘挂了，那么任意一台shadow master都能够挺身而出充当新的master。</p>
<blockquote>
<p>master机器的内存大小会不会成为系统存储容量的瓶颈呢？</p>
</blockquote>
<p>首先，一个chunk被设置成了64M，大大减少了一个文件所占用的chunk数量，因此，master中存储的数量也会大大减少。</p>
<p>其次，由于系统存储的是大文件，因此每一个文件，除了最后一个chunk以外，其他的chunk基本上都是存满的。</p>
<p>最后，加内存也不是什么难事。</p>
<p>一般64个bytes就可以存一个64M的chunk信息，因此大约可以用(内存大小)*(2^6)估算系统的容量，至少可以达到P级别。</p>
<blockquote>
<p>operation log是记下来了，但是重启的时候会不会因为日志回放的时间太久而导致很慢？</p>
</blockquote>
<p>当operation log达到一定大小时，系统会切换到一个新的日志。老的日志则会被回放，并存储在硬盘上，这个操作被称作checkpoint。当master重启时，直接加载checkpoint生成的内容，并回放新的日志，就可以完成了。</p>
<hr>
<p>参考文献：</p>
<p><a href="https://zhuanlan.zhihu.com/p/113161014" target="_blank" rel="noopener">6.824 2020 视频笔记三：GFS - 穆尼奥的文章 - 知乎</a> </p>
<p><a href="https://www.jianshu.com/p/540ae70c0500" target="_blank" rel="noopener">GFS(Google File System)读书笔记</a></p>
<p>【未整理-图解】-<a href="https://zhuanlan.zhihu.com/p/20673524" target="_blank" rel="noopener">硅谷之路9：深入浅出理解GFS - Mingche Su的文章 - 知乎</a> </p>
]]></content>
      <categories>
        <category>MIT-6.824</category>
      </categories>
  </entry>
  <entry>
    <title>PRC</title>
    <url>/MIT-6.824-PRC/</url>
    <content><![CDATA[<p>RPC，就是<strong>Remote Procedure Call</strong>的简称，翻译成中文就是<strong>远程过程调用</strong>，相对的是本地过程调用。</p>
<p>远程过程调用为了简化，避免一串 HTTP 请求的代码，使用类似本地调用的方式，发起远程调用。</p>
<p><strong>RPC要解决的两个问题：</strong></p>
<ol>
<li><strong>解决分布式系统中，服务之间的调用问题。</strong></li>
<li><strong>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</strong></li>
</ol>
<h3 id="PRC的实现"><a href="#PRC的实现" class="headerlink" title="PRC的实现"></a>PRC的实现</h3><p>可以不使用 HTTP 协议（文本传输协议），而是直接使用 Socket 的二进制方式来进行传输。</p>
<p><img data-src="/MIT-6.824-PRC/v2-43aee8a0ece93258fc6d6dc27f26ccea_1440w.jpg" alt="img"></p>
<h3 id="PRC-和-Restful-的比较"><a href="#PRC-和-Restful-的比较" class="headerlink" title="PRC 和 Restful 的比较"></a>PRC 和 Restful 的比较</h3><p>RPC风格，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;queryOrder?orderId&#x3D;123</span><br></pre></td></tr></table></figure>

<p>用Restful风格呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get  </span><br><span class="line">&#x2F;order?orderId&#x3D;123</span><br></pre></td></tr></table></figure>

<p>再精炼一点，甚至可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get  </span><br><span class="line">&#x2F;order&#x2F;123</span><br></pre></td></tr></table></figure>

<p><strong>RPC是面向过程，Restful是面向资源</strong>，并且使用了Http动词。从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。</p>
<h3 id="RPC没那么简单"><a href="#RPC没那么简单" class="headerlink" title="RPC没那么简单"></a>RPC没那么简单</h3><p><strong>要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架。</strong></p>
<h3 id="PRC的实现原理-远程调用计算机为例"><a href="#PRC的实现原理-远程调用计算机为例" class="headerlink" title="PRC的实现原理-远程调用计算机为例"></a>PRC的实现原理-远程调用计算机为例</h3><p>本机计算机</p>
<p><img data-src="/MIT-6.824-PRC/v2-f173a307dabb218a7f60c0be2629affc_1440w.jpg" alt="img"></p>
<p>分布式计算器：</p>
<p>CalculatorImpl和调用方不在同一个地址空间，那么就必须要进行远程过程调用：</p>
<p><img data-src="/MIT-6.824-PRC/v2-c6a24fe26f6baa71532dacd02a5364b7_r.jpg" alt="preview"></p>
<p><img data-src="/MIT-6.824-PRC/v2-43aee8a0ece93258fc6d6dc27f26ccea_1440w-1596454122000.jpg" alt="img"></p>
<p>其中左边的Client，对应的就是前面的Service A，而右边的Server，对应的则是Service B。</p>
<p>下面一步一步来理解一下：</p>
<ol>
<li>Service A的应用层代码中，调用了Calculator的一个实现类的add方法，希望执行一个加法运算；</li>
<li>这个Calculator实现类，内部并不是直接实现计算器的加减乘除逻辑，而是通过远程调用Service B的RPC接口，来获取运算结果，因此称之为<strong>Stub</strong>；</li>
<li>Stub怎么和Service B建立远程通讯呢？这时候就要用到<strong>远程通讯工具</strong>了，也就是图中的<strong>Run-time Library</strong>，这个工具将帮你实现远程通讯的功能，比如Java的<strong>Socket</strong>，就是这样一个库，当然，你也可以用基于Http协议的<strong>HttpClient</strong>，或者其他通讯工具类，都可以，<strong>RPC并没有规定说你要用何种协议进行通讯</strong>；</li>
<li>Stub通过调用通讯工具提供的方法，和Service B建立起了通讯，然后将请求数据发给Service B。需要注意的是，由于底层的网络通讯是基于<strong>二进制格式</strong>的，因此这里Stub传给通讯工具类的数据也必须是二进制，比如calculator.add(1,2)，你必须把参数值1和2放到一个Request对象里头（这个Request对象当然不只这些信息，还包括要调用哪个服务的哪个RPC接口等其他信息），然后<strong>序列化</strong>为二进制，再传给通讯工具类，这一点也将在下面的代码实现中体现；</li>
<li>二进制的数据传到Service B这一边了，Service B当然也有自己的通讯工具，通过这个通讯工具接收二进制的请求；</li>
<li>既然数据是二进制的，那么自然要进行<strong>反序列化</strong>了，将二进制的数据反序列化为请求对象，然后将这个请求对象交给Service B的Stub处理；</li>
<li>和之前的Service A的Stub一样，这里的Stub也同样是个“假玩意”，它所负责的，只是去解析请求对象，知道调用方要调的是哪个RPC接口，传进来的参数又是什么，然后再把这些参数传给对应的RPC接口，也就是Calculator的实际实现类去执行。很明显，如果是Java，那这里肯定用到了<strong>反射</strong>。</li>
<li>RPC接口执行完毕，返回执行结果，现在轮到Service B要把数据发给Service A了，怎么发？一样的道理，一样的流程，只是现在Service B变成了Client，Service A变成了Server而已：Service B反序列化执行结果-&gt;传输给Service A-&gt;Service A反序列化执行结果 -&gt; 将结果返回给Application，完毕。</li>
</ol>
<hr>
<p>参考文献：</p>
<p><a href="https://zhuanlan.zhihu.com/p/36427583" target="_blank" rel="noopener">如何给老婆解释什么是RPC - 柳树的文章 - 知乎</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/36528189" target="_blank" rel="noopener">如何实现一个简单的RPC - 柳树的文章 - 知乎</a></p>
]]></content>
      <categories>
        <category>MIT-6.824</category>
      </categories>
  </entry>
  <entry>
    <title>PrimaryBackup Replication</title>
    <url>/MIT-6.824-PrimaryBackup-Replication/</url>
    <content><![CDATA[<p>备份选择：操作 &gt; 状态 - 因为操作小得多</p>
<p>同步状态的层级：</p>
<ol>
<li>应用层（Application state）。如 GFS，更为高效，只需要发送高维操作即可，缺点是需要在应用层进行容错。</li>
<li>机器层（Machine level）。可以让运行在服务器上的应用无需改动而获取容错能力。但需要细粒度的同步机器事件（中断、DMA）；并且需要修改机器底层实现以发送这些事件。</li>
</ol>
<p>VM-FT 选择了后者，能力更强大，但也做出了更多牺牲。</p>
<p>VM-FT 系统使用一个额外的虚拟层 VMMonitor（ hypervisor == monitor == VMM ），当 client 请求到达 Primary 时，VMMonitor 一方面向本机转发请求、一方面向 Backup 的 VMMonitor 同步请求。处理完请求得到结果时，Primary 的 VMMonitor 会回复 Client，而 Backup 的 VMMonitor 会丢弃 Backup 产生的回复。</p>
<p>使用两种方法来检测 Primary 和 Backup 的健康状况：</p>
<ol>
<li>和 Primary/Backup 进行心跳。</li>
<li>监控 logging channel。</li>
</ol>
<h3 id="不确定性事件"><a href="#不确定性事件" class="headerlink" title="不确定性事件"></a>不确定性事件</h3><p>都有哪些不确定性（Non-deterministic）操作（operations）和事件（events）？</p>
<ul>
<li>输入的不确定性。系统中断事件。</li>
<li>奇怪指令。比如随机数、依赖时间戳的指令。</li>
<li>多核。不同机器可能以不同的方式在多核上交替运行指令。</li>
</ul>
<hr>
<p>参考文献：</p>
<p><a href="https://zhuanlan.zhihu.com/p/124335979" target="_blank" rel="noopener">6.824 2020 视频笔记四：VM-FT - 穆尼奥的文章 - 知乎</a></p>
]]></content>
      <categories>
        <category>MIT-6.824</category>
      </categories>
  </entry>
  <entry>
    <title>Raft</title>
    <url>/MIT-6.824-Raft/</url>
    <content><![CDATA[<h3 id="容错模式"><a href="#容错模式" class="headerlink" title="容错模式"></a>容错模式</h3><p>我们已经学习了以下几种容错模式（fault-tolerance pattern）：</p>
<ul>
<li>计算冗余：MapReduce，但是所有计算由单点 Master 进行调度。</li>
<li>数据冗余：GFS，也是依赖单点 Master 来对多个副本进行选主。</li>
<li>服务冗余：VMware-FT 依赖单个 TestAndSet 操作</li>
</ul>
<h3 id="Split-Brain"><a href="#Split-Brain" class="headerlink" title="Split Brain"></a>Split Brain</h3><p>共识算法中最大的问题在于——如何避免 <strong>Split Brain</strong>。</p>
<p>Split Brain 是如何产生的，其危害性为什么很大？</p>
<p>假设我们要对 test-and-set 服务进行备份。test-and-set，简而言之，就是一个锁服务。当多个 Client 同时请求服务时，只有其中一个能通过 Test（测试是否为0），获取锁，并设置 Server 状态为 1，则其他 Client 测试不能通过，从而不能获取锁。</p>
<p>考虑有以下四个系统角色：[C1, C2, S1, S2]，S1 和 S2 组成一个双备份的、可容错的系统，C1 和 C2 是使用此系统的客户端。假设 C1 可以和 S1 通信，但是与 S2 失联。那在只有 S1 的情况下，系统能够给 C1 正常提供服务么？</p>
<ol>
<li>如果 S2 真的宕机了，系统应当在 S2 缺席的情况下正常工作，否则系统就不能称之为是容错的（fault-tolerance）。</li>
<li>如果 S2 没有宕机，但是和 C1 失联了。则系统不能够给 C1 提供服务，因为 S2 可能正在给 C2 提供服务，如果让 S1 同时给 C1 服务，则会造成系统状态不一致，从而使服务出错：C1 和 C2 同时获取到锁。</li>
</ol>
<p><img data-src="https://pic4.zhimg.com/80/v2-5d68e05ac6ec8837cb6871c6cbdc862a_1440w.jpg" alt="img"></p>
<p>在此种情况下，我们面临一种选择的困境：</p>
<ol>
<li>要么不提供容错保证，尽管我们使用了双备份服务器。</li>
<li>要么仍然回复客户端请求，但由于 Split Brain 可能会发生，不保证一致性。</li>
</ol>
<p>问题在于，服务器 S1 无法区分 S2 是失联了（”server crashed”）还是网络故障了（network broken）。因为在这两种情况下，S1 看到的现象是一样的：向 S2 的请求得不到回复。S1 能够和 C1 通信，S2 能够和 C2 通信；但是 S1+C1 收不到 S2+C2 的回复，我们称这种情况为出现了<strong>网络分区</strong>（network partitionn）。</p>
<p>网络分区可能会持续很久，可能需要引入一个外力（比如说运维人员），来判断何时网络可信、何时服务器可信，才能打破僵局。那我们如何可以将容错做到自动化？答曰：<strong>多数票原则</strong>（majority vote）。</p>
<h3 id="多数票原则"><a href="#多数票原则" class="headerlink" title="多数票原则"></a>多数票原则</h3><p>多数票原则，要求系统集群包含奇数个服务器，以此来避免出现<strong>同票困境</strong>（symmetry）。如上面只有两个服务的情况，两方各执一词，就很难决定以谁为准。</p>
<p>在有奇数个服务器的系统中，我们只要获取多数票就可以保持系统正常运转，而不会陷入同票僵局（如 Raft 中的主选举、提交日志条目等）。多数票原则能够打破僵局，其原理也很简单：<em>不可能出现一个以上同时包含多数服务器的分区</em>。<strong>需要注意的是，这里的多数指的是构成系统所有的服务器的多数，而非存活服务器的多数。</strong></p>
<p>如果集群由 2f + 1 个服务器构成，最多能够承受 f 个服务器宕机，而仍能对外提供服务。</p>
<h3 id="Raft-概览"><a href="#Raft-概览" class="headerlink" title="Raft 概览"></a>Raft 概览</h3><p>Raft 一般表现为库的形式，运行在在每个副本（replica）服务器上，对<strong>多副本状态机</strong> （replicated state machine） 进行管理，主要负责对操作日志的同步。基于此，我们可以进一步构建可靠的 KV 存储层，主要负责状态的存储。</p>
<p><img data-src="/MIT-6.824-Raft/v2-cbff2b86199392f38184a85bab3f7b56_1440w.jpg" alt="img"></p>
<hr>
<h2 id="一、Raft算法概述"><a href="#一、Raft算法概述" class="headerlink" title="一、Raft算法概述"></a>一、Raft算法概述</h2><p>不同于Paxos算法直接从分布式一致性问题出发推导出来，Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。同时，Raft算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。</p>
<p>Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p>
<ul>
<li><strong>Leader</strong>：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li><strong>Follower</strong>：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li><strong>Candidate</strong>：Leader选举过程中的临时角色。</li>
</ul>
<p><img data-src="/MIT-6.824-Raft/v2-40d42747bec5c00503e4bd47566beb65_1440w.jpg" alt="Raft算法角色"></p>
<p>Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。</p>
<p>Raft算法角色状态转换如下：</p>
<p><img data-src="/MIT-6.824-Raft/v2-7f64a2df8f8817932ed047d35878bca9_1440w.jpg" alt="img"></p>
<p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p>
<p><img data-src="/MIT-6.824-Raft/v2-d3cc1cb525ac72dc59ed34148cb3199c_1440w.jpg" alt="img"></p>
<p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<h2 id="二、Leader选举"><a href="#二、Leader选举" class="headerlink" title="二、Leader选举"></a>二、Leader选举</h2><p>Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p>
<p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：</p>
<ul>
<li>赢得了多数的选票，成功选举为Leader；</li>
<li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li>
<li>没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。</li>
</ul>
<p><img data-src="/MIT-6.824-Raft/v2-0471619d1b78ba6d57326d97825d9495_r.jpg" alt="preview"></p>
<p>选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。</p>
<p>Raft保证选举出的Leader上一定具有最新的已提交的日志，这一点将在 <strong>四、安全性</strong> 中说明。</p>
<p>某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。</p>
<p>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。</p>
<p><img data-src="/MIT-6.824-Raft/v2-ee29a89e4eb63468e142bb6103dbe4de_1440w.jpg" alt="img"></p>
<hr>
<p>参考文献：</p>
<p>Raft算法详解 - 祥光的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32052223</a></p>
]]></content>
      <categories>
        <category>MIT-6.824</category>
      </categories>
  </entry>
  <entry>
    <title>Spanner</title>
    <url>/MIT-6.824-Spanner/</url>
    <content><![CDATA[<p><strong>Spanner</strong> 是谷歌研发的可横向扩展的、支持多版本的、可在全球范围进行分布式部署的、同步进行数据复制的分布式数据库。</p>
<hr>
<p>参考文献：</p>
<p><a href="https://www.jianshu.com/p/6ae6e7989161" target="_blank" rel="noopener">Google-Spanner论文的思考</a></p>
]]></content>
      <categories>
        <category>MIT-6.824</category>
      </categories>
  </entry>
  <entry>
    <title>Windows以太坊区块链环境搭建</title>
    <url>/windows-geth/</url>
    <content><![CDATA[<p>从环境搭建开始我的 <strong>智能合约</strong> 探索。</p>
<h3 id="一、安装Geth"><a href="#一、安装Geth" class="headerlink" title="一、安装Geth"></a>一、安装Geth</h3><p>以太坊社区提供了多种语言实现的客户端和开发库，官方推荐使用 <code>Go-ethererum</code>，也就是 <code>Geth</code> 。</p>
<p><a href="https://geth.ethereum.org/downloads/" target="_blank" rel="noopener">Geth 官网下载链接</a> 官网有一点小问题，通过 <code>F12</code> 找到了 <code>Windows</code> 的对应下载链接 <a href="https://gethstore.blob.core.windows.net/builds/geth-windows-amd64-1.9.15-0f77f34b.exe" target="_blank" rel="noopener">v1.9.15</a></p>
<p>源码在 <a href="https://github.com/ethereum/go-ethereum/releases" target="_blank" rel="noopener">Github - Geth - Release</a> </p>
<p>安装到路径 <code>C:\workspace\geth\</code> </p>
<p>命令行里面输入 <code>geth version</code>，正常反馈信息即为安装成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ geth version</span><br><span class="line">Geth</span><br><span class="line">Version: 1.9.15-stable</span><br><span class="line">Git Commit: 0f77f34bb67b640bd8af22b215f3d279a1e21170</span><br><span class="line">Git Commit Date: 20200608</span><br><span class="line">Architecture: amd64</span><br><span class="line">Protocol Versions: [65 64 63]</span><br><span class="line">Go Version: go1.14.2</span><br><span class="line">Operating System: windows</span><br><span class="line">GOPATH&#x3D;</span><br><span class="line">GOROOT&#x3D;C:\go</span><br></pre></td></tr></table></figure>

<h3 id="二、创建创世区块"><a href="#二、创建创世区块" class="headerlink" title="二、创建创世区块"></a>二、创建创世区块</h3><p>相同文件夹下面创建 <code>genesis.json</code> 文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"chainId"</span>: <span class="number">98</span>,</span><br><span class="line">        <span class="attr">"homesteadBlock"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip155Block"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip158Block"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"difficulty"</span> : <span class="string">"200000000"</span>,</span><br><span class="line">    <span class="attr">"gasLimit"</span> : <span class="string">"2100000"</span>,</span><br><span class="line">    <span class="attr">"alloc"</span>: &#123; </span><br><span class="line">        <span class="attr">"7df9a875a174b3bc565e6424a0050ebc1b2d1d82"</span>: &#123; <span class="attr">"balance"</span>: <span class="string">"300000"</span> &#125;,</span><br><span class="line">        <span class="attr">"f41c74c9ae680c1aa78f42e5647a62f353b7bdde"</span>: &#123; <span class="attr">"balance"</span>: <span class="string">"400000"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行中执行命令，生成创世区块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">geth --datadir &quot;.&#x2F;&quot; init genesis.json</span><br></pre></td></tr></table></figure>

<p>进入 <code>Geth</code>命令行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">geth --datadir &quot;.&#x2F;&quot; --nodiscover console 2&gt;&gt;geth.log</span><br></pre></td></tr></table></figure>

<p>提示以下内容</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Welcome to the Geth JavaScript console!</span><br><span class="line"></span><br><span class="line"><span class="function">instance: <span class="title">Geth</span>/<span class="title">v1</span>.9.15-<span class="title">stable</span>-0<span class="title">f77f34b</span>/<span class="title">windows</span>-<span class="title">amd64</span>/<span class="title">go1</span>.14.2                         </span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">block</span>: 0 (<span class="title">Thu</span> <span class="title">Jan</span> 01 1970 08:00:00 <span class="title">GMT</span>+0800 (<span class="title">CST</span>))                                 </span></span><br><span class="line"><span class="function"><span class="title">datadir</span>: <span class="title">C</span>:\<span class="title">workspace</span>\<span class="title">geth</span>                                                             </span></span><br><span class="line"><span class="function"><span class="title">modules</span>: <span class="title">admin</span>:1.0 <span class="title">debug</span>:1.0 <span class="title">eth</span>:1.0 <span class="title">ethash</span>:1.0 <span class="title">miner</span>:1.0 <span class="title">net</span>:1.0 <span class="title">personal</span>:1.0 <span class="title">rpc</span>:1.0 <span class="title">txpool</span>:1.0 <span class="title">web3</span>:1.0</span></span><br><span class="line"><span class="function">&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个新账户，记录地址</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line"><span class="function">Passphrase:</span></span><br><span class="line"><span class="function"><span class="title">Repeat</span> <span class="title">passphrase</span>:</span></span><br><span class="line"><span class="function">"0<span class="title">xc6d0ba74c35a0b8650a75d81e41bac0478c45efc</span>"</span></span><br><span class="line"><span class="function">&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动挖矿</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">geth --datadir "./" --networkid <span class="number">98</span> --mine --minerthreads=<span class="number">1</span> --etherbase=<span class="number">0</span>xc6d0ba74c35a0b8650a75d81e41bac0478c45efc</span><br></pre></td></tr></table></figure>

<p>以太坊是内存困难型的挖矿算法，首先需要生成 <code>DAG</code>，这个过程会占用大量的 CPU 资源</p>
<p><img data-src="/windows-geth/image-20200610172600263.png" alt="image-20200610172600263"></p>
<p><img data-src="/windows-geth/image-20200610173936739.png" alt="image-20200610173936739"></p>
<p>停留在 <code>Looking for peers</code> ，好像是因为没有太多全节点了，导致的卡住。</p>
<p>暂时挂载着，期待着后续的结果吧，如果一切顺利下一步就是挖到以太啦！</p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>以太坊上安全生成随机数</title>
    <url>/generate-random-number-on-ethereum-safely/</url>
    <content><![CDATA[<h2 id="用-keccak256-来制造随机数。"><a href="#用-keccak256-来制造随机数。" class="headerlink" title="用 keccak256 来制造随机数。"></a>用 <code>keccak256</code> 来制造随机数。</h2><p>Solidity 中最好的随机数生成器是 <code>keccak256</code> 哈希函数.</p>
<p>我们可以这样来生成一些随机数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成一个0到100的随机数:</span><br><span class="line">uint randNonce &#x3D; 0;</span><br><span class="line">uint random &#x3D; uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 &#x3D; uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></table></figure>

<p>这个方法首先拿到 <code>now</code> 的时间戳、 <code>msg.sender</code>、 以及一个自增数 <code>nonce</code> （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。</p>
<p>然后利用 <code>keccak</code> 把输入的值转变为一个哈希值, 再将哈希值转换为 <code>uint</code>, 然后利用 <code>% 100</code> 来取最后两位, 就生成了一个0到100之间随机数了。</p>
<h3 id="这个方法很容易被不诚实的节点攻击"><a href="#这个方法很容易被不诚实的节点攻击" class="headerlink" title="这个方法很容易被不诚实的节点攻击"></a>这个方法很容易被不诚实的节点攻击</h3><p>在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 <strong><em>transaction\</em></strong> 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 <strong><em>block\</em></strong> 发布在网络上。</p>
<p>一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。</p>
<p><strong>这就让我们的随机数函数变得可利用了</strong></p>
<p>我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (<code>random &gt;= 50</code> 算正面, <code>random &lt; 50</code> 算反面)。</p>
<p>如果我正运行一个节点，我可以 <strong>只对我自己的节点</strong> 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p>
<h2 id="所以我们该如何在以太坊上安全地生成随机数呢"><a href="#所以我们该如何在以太坊上安全地生成随机数呢" class="headerlink" title="所以我们该如何在以太坊上安全地生成随机数呢"></a>所以我们该如何在以太坊上安全地生成随机数呢</h2><p>因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" target="_blank" rel="noopener">这个 StackOverflow 上的讨论</a> 来获得一些主意。 一个方法是利用 <strong><em>oracle\</em></strong> 来访问以太坊区块链之外的随机数函数。</p>
<p>当然， 因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。</p>
<p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p>
<p>因为在这个教程中，我们只是在编写一个简单的游戏来做演示，也没有真正的钱在里面，所以我们决定接受这个不足之处，使用这个简单的随机数生成函数。但是要谨记它是不安全的。</p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo博客自动刷新</title>
    <url>/hexo-auto-refresh-by-browsersync/</url>
    <content><![CDATA[<p>Hexo 博客在写的过程中不能自动刷新网页，所以引入新的插件来自动刷新。</p>
<h3 id="安装-Browsersync"><a href="#安装-Browsersync" class="headerlink" title="安装 Browsersync"></a>安装 Browsersync</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g browser-sync</span><br></pre></td></tr></table></figure>

<p>安装结束后，测试安装是否成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">browser-sync --version</span><br></pre></td></tr></table></figure>

<h3 id="安装-Hexo-插件"><a href="#安装-Hexo-插件" class="headerlink" title="安装 Hexo 插件"></a>安装 Hexo 插件</h3><p>还需要给 Hexo 安装上插件（需要在 Hexo 目录下安装）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure>

<p>安装后像往常一样执行 <code>hexo s</code> 开启本地服务器，当相关文件被修改或者保存时，关联的浏览器页面会自带刷新。</p>
<h3 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h3><p>需要在 Hexo 根目录的 config.yml 里面添加以下配置，就可以啦！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">compress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="一些不足"><a href="#一些不足" class="headerlink" title="一些不足"></a>一些不足</h3><ul>
<li>变动后将重新加载整个页面，不能局部刷新</li>
<li>使用 Hexo 自带服务器时，无法在移动端调试</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>NexT 主题添加 canvas-nest 动画背景</title>
    <url>/next-canvas-nest/</url>
    <content><![CDATA[<p><code>NexT</code> 主题相较于我之前的 <code>Casper</code> 主题是一个很成熟的主题，很多定制化都已经别前人封装好了。</p>
<p>这篇文章来记录一下添加 <code>canvas-nest</code> 动画背景。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>使用 <code>NexT</code> 主题 <code>5.1.4</code> 版本</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>主题配置文件中已经预留好接口了，只需要在选择的动画背景选择 <code>true</code> 即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>更新到 <code>7</code> 版本的 <code>NexT</code> 之后暂时失效了。</p>
]]></content>
      <tags>
        <tag>NexT</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用npm快速生成</title>
    <url>/hexo-npm-fast-generate/</url>
    <content><![CDATA[<p>使用 <code>Hexo</code> 的时候，我们通常使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s &#x2F; hexo d</span><br></pre></td></tr></table></figure>

<p>但是在文件内容比较多的时候需要较长时间进行渲染处理，同时也需要输入三个命令。</p>
<p>之前配置 npm 里面的快捷命令的时候时好时坏，最近终于可以正常运行了，记录一下。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>打开 <code>package.json</code> 文件</p>
<p>我们会发现默认已经配置好了脚本(scripts)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "deploy": "hexo clean &amp;&amp; hexo g &amp;&amp; hexo d",</span><br><span class="line">    "start": "hexo clean &amp;&amp; hexo g &amp;&amp; hexo s"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>这个时候使用以下命令，就可以直接运行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm deploy </span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>如果想要每次输入的字母数更少一些，可以将 <code>json</code> 更改成以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;d&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&quot;,</span><br><span class="line">    &quot;s&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>这种时候运行输入以下命令就可以啦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run s</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 的 NexT 主题添加相关文章</title>
    <url>/hexo-next-related-posts/</url>
    <content><![CDATA[<p>更新 <code>NexT</code> 主题到最新版本之后，发现具有更多的定制功能，其中就有添加相关文章的选项。</p>
<p>使用 <code>https://github.com/tea3/hexo-related-popular-posts</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Related popular posts</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/tea3/hexo-related-popular-posts</span></span><br><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">相关文章</span></span><br><span class="line">  <span class="comment"># Custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">    <span class="comment">#isDate: false</span></span><br><span class="line">    <span class="comment">#isImage: false</span></span><br><span class="line">    <span class="comment">#isExcerpt: false</span></span><br></pre></td></tr></table></figure>

<p>配置完成，重新生成 <code>html</code> 文件就可以直接看到效果啦！</p>
<a id="more"></a>

<p><img data-src="/hexo-next-related-posts/image-20200610111926921.png" alt="image-20200610111926921"></p>
]]></content>
      <tags>
        <tag>NexT</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS-Serverless-Project</title>
    <url>/aws-serverless-project/</url>
    <content><![CDATA[<h1 id="AWS-Serverless-项目"><a href="#AWS-Serverless-项目" class="headerlink" title="AWS Serverless 项目"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/home/welcome" target="_blank" rel="noopener">AWS Serverless 项目</a></h1><h3 id="第一步：-搭建-Amazon-Lex-智能语音对答助手"><a href="#第一步：-搭建-Amazon-Lex-智能语音对答助手" class="headerlink" title="第一步： 搭建 Amazon Lex - 智能语音对答助手"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/supplement/rn0YB/exercise-1-1-creating-a-simple-bot-with-lex" target="_blank" rel="noopener">第一步： 搭建 Amazon Lex - 智能语音对答助手</a></h3><p>有几个小细节：slot、</p>
<h3 id="第二步：通过-S3-搭建一个静态的网站"><a href="#第二步：通过-S3-搭建一个静态的网站" class="headerlink" title="第二步：通过 S3 搭建一个静态的网站"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/supplement/6CVIl/exercise-1-2-creating-a-s3-bucket-and-configuring-as-a-static-website" target="_blank" rel="noopener">第二步：通过 S3 搭建一个静态的网站</a></h3><p>目前的版本和教程有一些不同，现在设置 <code>metadata</code> 和上传是在同一个页面，需要注意这个的设置。</p>
<p>从 403 - 404 - 到正常网页的显示～ 不过是一个静态的页面</p>
<p>联系了整体上传和部分文件的更新</p>
<h3 id="第三步：创建一个-CloudFront-Distribution"><a href="#第三步：创建一个-CloudFront-Distribution" class="headerlink" title="第三步：创建一个 CloudFront Distribution"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/supplement/3f74D/exercise-2-1-creating-a-cloudfront-distribution" target="_blank" rel="noopener">第三步：创建一个 CloudFront Distribution</a></h3><p>内容分发网络 - CloudFront 可以减少全球访问延迟，并且防止直接访问 S3 - Global Content Delivery Network</p>
<ol>
<li><p>创建并且配置 Cloud Front</p>
</li>
<li><p>配置 S3 - 发现策略已经被修改，我们要再修改一下</p>
<ol>
<li><p>这样的话只允许特定的进行访问</p>
</li>
<li><p>现在登录原来的网站发现 403 Fobidden 了 - 被禁止访问了 <a href="http://20210308-hanwen.s3-website-us-east-1.amazonaws.com/" target="_blank" rel="noopener">原来的网址</a></p>
</li>
<li><p>现在在 CloudFront 里面找到 对应的新网址 - 可以正常访问</p>
<p><a href="https://dodt9kh7nx9h5.cloudfront.net/" target="_blank" rel="noopener">https://dodt9kh7nx9h5.cloudfront.net/</a></p>
</li>
</ol>
</li>
</ol>
<h3 id="第四步：创建-API-Gateway-并且连接到我们的网站上"><a href="#第四步：创建-API-Gateway-并且连接到我们的网站上" class="headerlink" title="第四步：创建 API Gateway 并且连接到我们的网站上"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/supplement/4VZFE/exercise-2-2-amazon-api-gateway" target="_blank" rel="noopener">第四步：创建 API Gateway 并且连接到我们的网站上</a></h3><p>通过 API Gateway 创建后端 API</p>
<p>首先通过Mock来进行模拟 - hard coded data</p>
<p>Cross Domain - CORS 启用跨域的支持</p>
<p>然后部署 API，得到一个网址 <strong>调用 URL:</strong> <a href="https://a6qv4uuyug.execute-api.us-east-1.amazonaws.com/test" target="_blank" rel="noopener">https://a6qv4uuyug.execute-api.us-east-1.amazonaws.com/test</a></p>
<p>最后集成到网站上面，就实现了～</p>
<h3 id="第五步：创建一个Lambda函数"><a href="#第五步：创建一个Lambda函数" class="headerlink" title="第五步：创建一个Lambda函数"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/supplement/YlppW/exercise-3-1-creating-an-aws-lambda-function" target="_blank" rel="noopener">第五步：创建一个Lambda函数</a></h3><p>创建并且配置Lambda函数，并且修改代码，Deploy</p>
<p>在 API Gateway 里面修改 Mock 为 Lambda 函数 （原来相当于是模拟，现在是连接到真实的后端上面去了）</p>
<blockquote>
<p>提供有关此方法将调用的目标后端以及是否应修改传入请求数据的信息。</p>
</blockquote>
<p>还需要重新开启 CORS，然后还要部署 API</p>
<p>原网址内容得到更新：<a href="https://a6qv4uuyug.execute-api.us-east-1.amazonaws.com/test" target="_blank" rel="noopener">https://a6qv4uuyug.execute-api.us-east-1.amazonaws.com/test</a></p>
<p>访问app网站的时候，注意是访问 cloudfront 的网址</p>
<h3 id="第六步：DynamoDB"><a href="#第六步：DynamoDB" class="headerlink" title="第六步：DynamoDB"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/supplement/Bkncm/exercise-3-2-amazon-dynamodb" target="_blank" rel="noopener">第六步：DynamoDB</a></h3><p>创建一个DB，然后通过 lambda 函数给 DB 中添加信息，并且可以在线和 DB 交互查询到添加的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.handler = <span class="function"><span class="keyword">function</span>(<span class="params">event, context, callback</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> </span><br><span class="line">    	AWS = <span class="built_in">require</span>(<span class="string">"aws-sdk"</span>),</span><br><span class="line">    	fs = <span class="built_in">require</span>(<span class="string">"fs"</span>),</span><br><span class="line">      item = &#123;&#125;,</span><br><span class="line">    	some_temp_int = <span class="number">0</span>,</span><br><span class="line">		  params = &#123;&#125;,</span><br><span class="line">      DDB = <span class="keyword">new</span> AWS.DynamoDB;</span><br><span class="line">    </span><br><span class="line">    AWS.config.update(&#123;</span><br><span class="line">        region: <span class="string">"us-east-1"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    fs.readFileSync(<span class="string">"cities.csv"</span>, <span class="string">"utf8"</span>).split(<span class="string">'\n'</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item_str</span>)</span>&#123;</span><br><span class="line">        params.ReturnConsumedCapacity = <span class="string">"TOTAL"</span>;</span><br><span class="line">        params.TableName = <span class="string">"weather"</span>;</span><br><span class="line">        params.Item = &#123;</span><br><span class="line">            <span class="string">"sc"</span>: &#123;</span><br><span class="line">                <span class="string">"S"</span>: item_str.split(<span class="string">","</span>)[<span class="number">0</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"t"</span>: &#123;</span><br><span class="line">                <span class="string">"N"</span>: <span class="built_in">String</span>(item_str.split(<span class="string">","</span>)[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      	</span><br><span class="line">        DDB.putItem(params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.error(err);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//ignore output</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     callback(<span class="literal">null</span>, <span class="string">"ok"</span>);</span><br><span class="line"> &#125;, <span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在将 get__weather 这个 lambda 函数也进行了修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">event, context, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> </span><br><span class="line">        AWS = <span class="built_in">require</span>(<span class="string">"aws-sdk"</span>),</span><br><span class="line">        DDB = <span class="keyword">new</span> AWS.DynamoDB(&#123;</span><br><span class="line">            apiVersion: <span class="string">"2012-08-10"</span>,</span><br><span class="line">            region: <span class="string">"us-east-1"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        </span><br><span class="line">        city_str = event.city_str.toUpperCase(),</span><br><span class="line">        data = &#123;</span><br><span class="line">            city_str: city_str,</span><br><span class="line">            temp_int_str: <span class="number">72</span></span><br><span class="line">        &#125;,</span><br><span class="line">        response = &#123;&#125;,</span><br><span class="line">        params = &#123;</span><br><span class="line">            TableName: <span class="string">"weather"</span>,</span><br><span class="line">            KeyConditionExpression: <span class="string">"sc = :v1"</span>,</span><br><span class="line">            ExpressionAttributeValues: &#123;</span><br><span class="line">                <span class="string">":v1"</span>:&#123;</span><br><span class="line">                    S: city_str</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">   	DDB.query(params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span></span><br><span class="line">       		item = &#123;&#125;,</span><br><span class="line">           	response = &#123;</span><br><span class="line">            	statusCode: <span class="number">200</span>,</span><br><span class="line">            	headers: &#123;&#125;,</span><br><span class="line">            	body: <span class="literal">null</span></span><br><span class="line">        	&#125;;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            response.statusCode = <span class="number">500</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            response.body = err;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// console.log(data.Items[0]);</span></span><br><span class="line">            <span class="keyword">var</span> data = data.Items[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(data &amp;&amp; data.t)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data.sc.S + <span class="string">" and "</span> + data.t.N);</span><br><span class="line">            	item = &#123;</span><br><span class="line">                    temp_int:<span class="built_in">Number</span>(data.t.N),</span><br><span class="line">                    city_str: data.sc.S</span><br><span class="line">            	&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                item = &#123;</span><br><span class="line">                	city_str: event.city_str</span><br><span class="line">                  <span class="comment">//when we don't return a temp, the client can say city not found</span></span><br><span class="line">            	&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        response = item;</span><br><span class="line">       <span class="comment">// console.log(response);</span></span><br><span class="line">        callback(<span class="literal">null</span>, response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">exports.handler = handler;</span><br></pre></td></tr></table></figure>

<p>到现在为止，一个app已经成型了，可以交互式查询城市的温度，并且返回基于温度的建议。</p>
<p><img data-src="/aws-serverless-project/demo1.png" alt="image-20210309145433952"></p>
<h3 id="Smarter-LEX"><a href="#Smarter-LEX" class="headerlink" title="Smarter LEX"></a><a href="https://www.coursera.org/learn/aws-fundamentals-building-serverless-applications/supplement/lqiYG/exercise-4-1-make-amazon-lex-smarter" target="_blank" rel="noopener">Smarter LEX</a></h3><p>转化我们的 text app to voice enabled app.</p>
<p>新创建了一个 Lambda 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.handler = <span class="function"><span class="keyword">function</span>(<span class="params">event, ctx, cb</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> </span><br><span class="line">    my_response = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(event.currentIntent.slots.city_str)&#123;</span><br><span class="line">        <span class="comment">// we have the city already awesome keep going</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//we need to ask for (elicit) a city</span></span><br><span class="line">        my_response.statusCode = <span class="number">200</span>;</span><br><span class="line">        my_response.body = &#123;</span><br><span class="line">            <span class="string">"dialogAction"</span>: &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"ElicitSlot"</span>,</span><br><span class="line">                <span class="string">"message"</span>: &#123;</span><br><span class="line">                    <span class="string">"contentType"</span>: <span class="string">"PlainText"</span>,</span><br><span class="line">                    <span class="string">"content"</span>: <span class="string">"Name the city your cat lives in, thanks"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"intentName"</span>: <span class="string">"CatWeather"</span>,</span><br><span class="line">                <span class="string">"slots"</span>: &#123;</span><br><span class="line">                    <span class="string">"city_str"</span>: <span class="literal">null</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"slotToElicit"</span> : <span class="string">"city_str"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> cb(<span class="literal">null</span>, my_response.body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        city_str = event.currentIntent.slots.city_str,</span><br><span class="line">        AWS = <span class="built_in">require</span>(<span class="string">"aws-sdk"</span>),</span><br><span class="line">        DDB = <span class="keyword">new</span> AWS.DynamoDB(&#123;</span><br><span class="line">            apiVersion: <span class="string">"2012-08-10"</span>,</span><br><span class="line">            region: <span class="string">"us-east-1"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        lookup_name_str = city_str.toUpperCase(),</span><br><span class="line">        params = &#123;</span><br><span class="line">            TableName: <span class="string">"weather"</span>,</span><br><span class="line">            KeyConditionExpression: <span class="string">"sc = :v1"</span>,</span><br><span class="line">            ExpressionAttributeValues: &#123;</span><br><span class="line">                <span class="string">":v1"</span>:&#123;</span><br><span class="line">                    <span class="string">"S"</span>: lookup_name_str</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            ProjectionExpression: <span class="string">"t"</span></span><br><span class="line">        &#125;; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">    DDB.query(params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(data.Items &amp;&amp; data.Items[<span class="number">0</span>] &amp;&amp; data.Items[<span class="number">0</span>].t)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"city weather found"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(data.Items[<span class="number">0</span>]);</span><br><span class="line">            my_response.statusCode = <span class="number">200</span>;</span><br><span class="line">            my_response.body = &#123;</span><br><span class="line">                <span class="string">"sessionAttributes"</span>: &#123;</span><br><span class="line">                    <span class="string">"temp_str"</span>: data.Items[<span class="number">0</span>].t.N,</span><br><span class="line">                    <span class="string">"city_str"</span>: event.currentIntent.slots.city_str</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"dialogAction"</span>:&#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"Close"</span>,</span><br><span class="line">                    <span class="string">"fulfillmentState"</span>: <span class="string">"Fulfilled"</span>,</span><br><span class="line">                    <span class="string">"message"</span>: &#123;</span><br><span class="line">                        <span class="string">"contentType"</span>: <span class="string">"PlainText"</span>,</span><br><span class="line">                        <span class="string">"content"</span>: data.Items[<span class="number">0</span>].t.N</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"city weather not found for "</span> + lookup_name_str);</span><br><span class="line">            my_response.statusCode = <span class="number">200</span>;</span><br><span class="line">            my_response.body = &#123;</span><br><span class="line">                <span class="string">"dialogAction"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"ElicitSlot"</span>,</span><br><span class="line">                    <span class="string">"message"</span>: &#123;</span><br><span class="line">                        <span class="string">"contentType"</span>: <span class="string">"PlainText"</span>,</span><br><span class="line">                        <span class="string">"content"</span>: <span class="string">"Please try another city, we couldn't find the weather for that city"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"intentName"</span>: <span class="string">"CatWeather"</span>,</span><br><span class="line">                    <span class="string">"slots"</span>: &#123;</span><br><span class="line">                        <span class="string">"city_str"</span>: <span class="literal">null</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"slotToElicit"</span> : <span class="string">"city_str"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cb(<span class="literal">null</span>, my_response.body);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>三次测试：</p>
<ol>
<li>正常的输入输出</li>
<li>输入的城市不在数据库中 - 找不到这个城市</li>
<li>城市部分的输入为 null - 请求 name 的城市</li>
</ol>
<p>然后在 LEX 中配置连接到 lambda 函数，可以正常问询。</p>
<p>但是有一个问题是：DENVER 的后面不能加问号</p>
<p>通过增加一个新的匹配项就解决了 - 可能是把问号也识别进去了。</p>
<p>最后一步是在 API Gateway 中激活我的 lex_proxy</p>
<p><a href="https://dodt9kh7nx9h5.cloudfront.net/voice.html" target="_blank" rel="noopener">https://dodt9kh7nx9h5.cloudfront.net/voice.html</a></p>
<p><img data-src="/aws-serverless-project/demo2.png" alt="image-20210309155335356"></p>
<hr>
<p>Everything is Done！</p>
<p>Thanks to DENVER～ </p>
<p>Thanks to AWS～</p>
]]></content>
      <tags>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>Serverless</title>
    <url>/serverless-introduction/</url>
    <content><![CDATA[<h1 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h1><p>相对于微服务是更加细粒度的服务架构模式，目前抽象级别更高的。</p>
<p>函数暴露的形式进行发布，所以又称为 FaaS。提供了代码可以运行的平台。</p>
<p>不需要关心计算资源，相较于 PaaS，计算能力是无限的。</p>
<p><img data-src="/serverless-introduction/1450963-20190708100448985-80323474.webp" alt="img"></p>
<blockquote>
<p><em>如果你的PaaS能够有效地在20毫秒内启动实例并运行半秒,那么就可以称之为Serverless”。</em></p>
<p><em>–摘抄自《从 IaaS 到 FaaS—— Serverless架构的前世今生》</em></p>
</blockquote>
<a id="more"></a>

<h3 id="最强大的功能是-事件驱动"><a href="#最强大的功能是-事件驱动" class="headerlink" title="最强大的功能是  - 事件驱动"></a>最强大的功能是  - <strong>事件驱动</strong></h3><p>Serverless 本质是事件驱动的。</p>
<ul>
<li>上传图片时触发Lambda函数生成缩略图，用于做网站图片缓存。</li>
<li>上传视频时触发Lambda函数生成视频摘要信息，截取关键帧。</li>
</ul>
<h3 id="记录变化途径"><a href="#记录变化途径" class="headerlink" title="记录变化途径"></a>记录变化途径</h3><p>云计算经历了从IDC -&gt; IaaS -&gt; PaaS -&gt; Serverless/FaaS 的发展历程</p>
<p><img data-src="/serverless-introduction/1450963-20190708100500351-507271724.webp" alt="img"></p>
<p>IaaS(Infrastructure as a Service) 基础设施即服务，_服务商提供底层/物理层基础设施资源（服务器，数据中心，环境控制，电源，服务器机房），用户需要通过IaaS提供的服务平台购买虚拟资源，选择操作系统，安装软件，部署程序，监控应用。</p>
<p><img data-src="/serverless-introduction/1450963-20190708100507728-684923140.webp" alt="img"></p>
<p>PaaS(Platform as a Service) 平台即服务，服务商提供基础设施底层服务，提供操作系统（Windows，Linux）、数据库服务器、Web服务器、负载均衡器和其他中间件，相对于IaaS客户仅仅需要自己控制上层的应用程序部署与应用托管的环境。</p>
<p><img data-src="/serverless-introduction/1450963-20190708100513269-1002353393.webp" alt="img"></p>
<p>SaaS(Software as a Service) 软件即服务， 服务商提供基于软件的解决方案，如OA、CRM、MIS、ERP、HRM、CM、Office 365、iCloud等，客户不需考虑任何形式的专业技术知识，只需要通过服务商平台获取软件使用即可。</p>
]]></content>
  </entry>
  <entry>
    <title>图灵完备</title>
    <url>/turing-completeness/</url>
    <content><![CDATA[<p>在<a href="https://zh.wikipedia.org/wiki/可计算性理论" target="_blank" rel="noopener">可计算性理论</a>里，如果一系列操作数据的规则（如<a href="https://zh.wikipedia.org/wiki/指令集" target="_blank" rel="noopener">指令集</a>、<a href="https://zh.wikipedia.org/wiki/编程语言" target="_blank" rel="noopener">编程语言</a>、<a href="https://zh.wikipedia.org/wiki/細胞自動機" target="_blank" rel="noopener">细胞自动机</a>）可以用来模拟<a href="https://zh.wikipedia.org/wiki/图灵机" target="_blank" rel="noopener">单带图灵机</a>，那么它是<strong>图灵完全的</strong>。这个词源于引入图灵机概念的数学家<a href="https://zh.wikipedia.org/wiki/艾伦·图灵" target="_blank" rel="noopener">艾伦·图灵</a>。</p>
<p>虽然<a href="https://zh.wikipedia.org/wiki/图灵机" target="_blank" rel="noopener">图灵机</a>会受到储存能力的<a href="https://zh.wikipedia.org/wiki/物理" target="_blank" rel="noopener">物理</a>限制，图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”。</p>
<p>PPT 是图灵完备的，神奇！</p>
]]></content>
  </entry>
  <entry>
    <title>Help Rather Than Recycle - Alleviating Cold Startup in Serverless Computing with Inter-Function Container Sharing</title>
    <url>/help-rather-than-recycle-alleviating-cold-startup-in-serverless-computing-with-inter-function-container-sharing/</url>
    <content><![CDATA[<p>主要是三个 level 的创新。</p>
<a id="more"></a>

<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 - Introduction"></a>1 - Introduction</h3><p>从闲置的warm容器借共享的资源过来。</p>
<p><strong>三个挑战：</strong></p>
<ol>
<li>不稳定，QoS 下降</li>
<li>借的时候会需要定向的配置，这个过程会需要额外的时间</li>
<li>被借的那个人也需要考虑：去帮谁呢？</li>
</ol>
<p><strong>Pagurus 系统的三种容器状态：</strong></p>
<ol>
<li>zygote containers</li>
<li>private containers</li>
<li>helper containers</li>
</ol>
<p><strong>主要的贡献：</strong></p>
<ol>
<li>An inter-function sharing mechanism that alleviates cold startup with security guarantee</li>
<li>A similarity-based container image re-packing policy</li>
<li>A cluster-level function balancing mechanism</li>
</ol>
<h3 id="3-Motivation"><a href="#3-Motivation" class="headerlink" title="3 - Motivation"></a>3 - Motivation</h3><p><strong>3.1 - Existence of Excessive Warm Containers</strong></p>
<p>通过实验发现真的存在。</p>
<p><strong>3.2 - Inter-Function Sharing</strong></p>
<ol>
<li>负载在动态的变化</li>
<li>容器需要安装不同的软件包</li>
<li>共享可能会伤害其他的安全性</li>
</ol>
<h3 id="4-Design-of-Pagurus"><a href="#4-Design-of-Pagurus" class="headerlink" title="4 - Design of Pagurus"></a>4 - Design of Pagurus</h3><p><img data-src="/help-rather-than-recycle-alleviating-cold-startup-in-serverless-computing-with-inter-function-container-sharing/image-20210310204418282.png" alt="image-20210310204418282"></p>
<p>合子容器包含两种的运行环境，然后 load code；基于合子容器的 fork 会产生 helper 容器。</p>
<p><strong>Intra:</strong> 功能内部的管理最重要是 <strong>识别闲置状态</strong> + <strong>确保共享的时候不伤害安全性</strong></p>
<ul>
<li>re-packing operator：让 private 容器编程 zygote 容器</li>
<li>zygote fork：创造 helper 容器</li>
<li>code copy：复制需要帮助的代码 到内存中</li>
</ul>
<p><strong>Inter:</strong> 很难决定要从哪儿进行 borrow</p>
<p>通过分析package的相似性。</p>
<p><strong>Balancer - 跨界点node - 具体的执行机制</strong></p>
<p>Pagurus works in the following steps. Suppose functions A and B are on the same node, and A already generates a zygote container that installs the software packages for B. Once a query of B tends to suffer a cold startup, B’s intra-function manager requests a helper container from the inter-function scheduler. Then, the inter-function scheduler schedules a zygote container from A to B. By forking A’s zygote container and load B’s code, B obtains a helper container and can execute this query without cold startup. If all the functions on the node do not have zygote containers for B, later queries of B are routed to other nodes that have excessive containers.</p>
<hr>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理和反向代理</title>
    <url>/forward-and-backword-proxy/</url>
    <content><![CDATA[<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>提到 <code>反向代理</code>，必然先提到 <code>正向代理</code>。</p>
<p>正向代理 (forward) 是一个位于客户端【用户 A 】和原始服务器 (origin server) 【服务器 B 】之间的服务器【代理服务器 Z 】，为了从原始服务器取得内容，用户 A 向代理服务器 Z 发送一个请求并指定目标 (服务器 B)， 然后代理服务器 Z 向服务器 B 转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>如下图（图来自网络）：</p>
<p><img data-src="/forward-and-backword-proxy/forwards_proxy-1591876806097.jpg" alt="正向代理示意图"></p>
<p>从上图可以看出，所谓的 <code>正向代理</code> 就是 <code>代理服务器替代访问方【用户 A 】去访问目标服务器【服务器 B 】</code>，在现实中的例子就是『翻墙』！但如果代理服务器 Z 被完全控制（或不完全控制），就不行了。</p>
<p>而 <code>反向代理</code> 与正向代理相反，对客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间（name-space）中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。</p>
<p>使用反向代理服务器主要核心作用如下：</p>
<ol>
<li>保护和隐藏原始资源服务器</li>
</ol>
<p><img data-src="/forward-and-backword-proxy/backward_proxy_1-1591876806585.jpg" alt="反向代理原理图"></p>
<p>从上图可以看出，用户 A 始终认为它访问的是代理服务器 Z 而不是原始服务器 B，但实际上反向代理服务器接受用户 A 的应答，从原始资源服务器 B 中取得用户 A 的需求资源，然后发送给用户 A。由于防火墙的作用，只允许代理服务器 Z 访问原始资源服务器 B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器 B，但用户 A 并不知情。</p>
<ol start="2">
<li>负载均衡</li>
</ol>
<p><img data-src="/forward-and-backword-proxy/backward_balance-1591876806098.jpg" alt="反向代理负载均衡示例图"></p>
<p>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器 B 的时候，让不同的代理服务器 Z（x）去应答不同的用户，然后发送不同用户需要的资源。</p>
<p>当然 <code>反向代理服务器</code> 像 <code>正向代理服务器</code> 一样拥有 CACHE 的作用，它可以缓存原始资源服务器 B 的资源，而不是每次都要向原始资源服务器 B 请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户 X 来自同一个网络，那么用户 X 访问反向代理服务器 X，就会得到很高质量的速度。这正是 <code>CDN 技术</code> 的核心。如下图：</p>
<p><img data-src="/forward-and-backword-proxy/cdn-1591876805954.jpg" alt="CDN 原理图"></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集的划分</title>
    <url>/split-dataset/</url>
    <content><![CDATA[<ol>
<li><p>验证集和测试集不相交，验证集和训练集不相交，测试集和训练集不相交。</p>
</li>
<li><p><strong>三者的关系：</strong></p>
<ul>
<li>训练集用于训练模型参数</li>
<li>测试集用于估计模型对样本的泛化误差</li>
<li>验证集用于“训练”模型的超参数。</li>
</ul>
</li>
</ol>
<p>验证集用于找到最适合的超参数，这个过程不调整模型的参数（不是学习过程）</p>
<p>测试集只使用一次，不调整任何参数，直接测试模型的结果。</p>
<ol start="3">
<li><strong>交叉验证</strong></li>
</ol>
<p><img data-src="/split-dataset/20180206150941131.png" alt="img"></p>
<p>训练集进行划分，然后多次进行训练过程。</p>
<h3 id="K-Fold"><a href="#K-Fold" class="headerlink" title="K-Fold"></a>K-Fold</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line">X = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">kf = KFold(n_splits=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> kf.split(X):</span><br><span class="line">    print(<span class="string">"%s %s"</span> % (train, test))</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1 2 3] [0]</span><br><span class="line">[0 2 3] [1]</span><br><span class="line">[0 1 3] [2]</span><br><span class="line">[0 1 2] [3]</span><br></pre></td></tr></table></figure>

<h3 id="StratifiedKFold"><a href="#StratifiedKFold" class="headerlink" title="StratifiedKFold"></a>StratifiedKFold</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">              [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>],</span><br><span class="line">              [<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>],</span><br><span class="line">              [<span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>],</span><br><span class="line">              [<span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>],</span><br><span class="line">              [<span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>]])</span><br><span class="line"></span><br><span class="line">y = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">stratified_folder = StratifiedKFold(n_splits=<span class="number">4</span>, random_state=<span class="number">0</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> stratified_folder.split(X, y):</span><br><span class="line">    print(<span class="string">"Stratified Train Index:"</span>, train_index)</span><br><span class="line">    print(<span class="string">"Stratified Test Index:"</span>, test_index)</span><br><span class="line">    print(<span class="string">"Stratified y_train:"</span>, y[train_index])</span><br><span class="line">    print(<span class="string">"Stratified y_test:"</span>, y[test_index], <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stratified Train Index: [1 3 4 5 6 7]</span><br><span class="line">Stratified Test Index: [0 2]</span><br><span class="line">Stratified y_train: [1 0 1 1 0 0]</span><br><span class="line">Stratified y_test: [1 0] </span><br><span class="line"></span><br><span class="line">Stratified Train Index: [0 2 4 5 6 7]</span><br><span class="line">Stratified Test Index: [1 3]</span><br><span class="line">Stratified y_train: [1 0 1 1 0 0]</span><br><span class="line">Stratified y_test: [1 0] </span><br><span class="line"></span><br><span class="line">Stratified Train Index: [0 1 2 3 5 7]</span><br><span class="line">Stratified Test Index: [4 6]</span><br><span class="line">Stratified y_train: [1 1 0 0 1 0]</span><br><span class="line">Stratified y_test: [1 0] </span><br><span class="line"></span><br><span class="line">Stratified Train Index: [0 1 2 3 4 6]</span><br><span class="line">Stratified Test Index: [5 7]</span><br><span class="line">Stratified y_train: [1 1 0 0 1 0]</span><br><span class="line">Stratified y_test: [1 0]</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>ubuntu pip安装</title>
    <url>/ubuntu-pip-install/</url>
    <content><![CDATA[<p>ubuntu pip 安装的时候常需要源，这里记录一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install * -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>aws 上面机器由于内存比较小，安装的时候会遇到 MemoryError</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install * --no-cache-dir</span><br></pre></td></tr></table></figure>

<p>安装 opencv</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y libsm6 libxext6 libxrender-dev libglib2.0-0</span><br><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>





<a id="more"></a>

]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Flask快速部署一个网站</title>
    <url>/deploy-a-website-by-flask/</url>
    <content><![CDATA[<ol>
<li><p>Pycharm 生成 Flask 项目</p>
</li>
<li><p>还是使用直白的 Debug 运行模式，赶紧开始工作起来啦</p>
</li>
<li><p>端口容易出现占用的情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> $(lsof -ti:5000)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Flask-实现上传"><a href="#Flask-实现上传" class="headerlink" title="Flask 实现上传"></a>Flask 实现上传</h3><ol>
<li>上传的代码，这里整理一下方便之后复用</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化上传的文件夹信息</span></span><br><span class="line">UPLOAD_FOLDER = <span class="string">'./uploads'</span></span><br><span class="line">ALLOWED_EXTENSIONS = &#123;<span class="string">'pdf'</span>&#125;</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">dropzone = Dropzone(app)</span><br><span class="line"><span class="comment"># 配置上传的文件夹和上传文件最大大小限制</span></span><br><span class="line">app.config[<span class="string">'UPLOAD_FOLDER'</span>] = UPLOAD_FOLDER</span><br><span class="line">app.config[<span class="string">'MAX_CONTENT_LENGTH'</span>] = <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否是允许的文件，注意-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allowed_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'.'</span> <span class="keyword">in</span> filename <span class="keyword">and</span> filename.rsplit(<span class="string">'.'</span>, <span class="number">1</span>)[<span class="number">-1</span>].lower() <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册网址 绑定函数</span></span><br><span class="line"><span class="meta">@app.route('/uploads/&lt;filename&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uploaded_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> send_from_directory(app.config[<span class="string">'UPLOAD_FOLDER'</span>], filename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是先上传</span></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        file = request.files[<span class="string">'file'</span>]</span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            file.save(os.path.join(app.config[<span class="string">'UPLOAD_FOLDER'</span>], filename))</span><br><span class="line">            file_url = url_for(<span class="string">'uploaded_file'</span>, filename=filename)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'uploaded_file'</span>, filename=filename))</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">'upload.html'</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>前端实现拖拽上传的效果，使用 <code>dropzone.css</code> 和 <code>dropzone.js</code>。主要的 <code>HTML</code>的代码如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Flask upload with Dropzone example&lt;/title&gt;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"&#123;&#123; url_for('static', filename='css/dropzone.css') &#125;&#125;"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- Change action value to your upload address --&gt;</span><br><span class="line">    &lt;form action="&#123;&#123; url_for('upload_file') &#125;&#125;" class="dropzone" method="POST" enctype="multipart/form-data"&gt;&lt;/form&gt;</span><br><span class="line">    &lt;header&gt;woshi555&lt;/header&gt;</span><br><span class="line">    &lt;script src="&#123;&#123; url_for('static', filename='js/dropzone.js') &#125;&#125;"&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>继续和我的基础环境绑定</li>
</ol>
<hr>
<h3 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h3><p>之前也遇见过部署的时候网页就没了，这次发现是因为 <code>Flask</code> 自带的服务器在 ssh 退出之后就不可用了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup python app.py 1&gt;result.txt 2&gt;err.txt &amp;</span><br></pre></td></tr></table></figure>

<p>注意：最后的 &amp; 才表示后台运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ux</span><br><span class="line">ps- aux</span><br><span class="line"></span><br><span class="line">lsof -i :5000</span><br><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="继续更新-flask-dropzone"><a href="#继续更新-flask-dropzone" class="headerlink" title="继续更新 - flask-dropzone"></a>继续更新 - flask-dropzone</h3><p>先配置，然后再 <code>dropzone = Dropzone(app)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.config[<span class="string">'UPLOAD_FOLDER'</span>] = UPLOAD_FOLDER</span><br><span class="line"><span class="comment"># app.config['DROPZONE_REDIRECT_VIEW'] = 'hello'  # set redirect view</span></span><br><span class="line">app.config[<span class="string">'DROPZONE_REDIRECT_VIEW'</span>] = <span class="string">'result'</span>  <span class="comment"># function-name (not the true url)</span></span><br><span class="line">app.config[<span class="string">'DROPZONE_ALLOWED_FILE_CUSTOM'</span>] = <span class="literal">True</span></span><br><span class="line">app.config[<span class="string">'DROPZONE_ALLOWED_FILE_TYPE'</span>] = <span class="string">'.pdf'</span></span><br><span class="line"></span><br><span class="line">dropzone = Dropzone(app)</span><br></pre></td></tr></table></figure>

<p>限制了文件的格式是 PDF，可以实现最后选框上传的时候就是 PDF 文件</p>
<p>跳转只能这样显示的写，不能使用 <code>redirect</code> ，使用的是函数的名字</p>
<p><strong>html文件中</strong>很容易就可以做出来了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    &#123;&#123; dropzone.load_css() &#125;&#125;</span><br><span class="line">    &#123;&#123; dropzone.style('border: 2px dashed #0087F7; margin: 10%') &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123; dropzone.create(action="upload_file") &#125;&#125;</span><br><span class="line">    &#123;&#123; dropzone.load_js() &#125;&#125;</span><br><span class="line">    &#123;&#123; dropzone.config() &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum-Studio-Sample-Hello-World</title>
    <url>/ethereum-studio-sample-hello-world/</url>
    <content><![CDATA[<h1 id="Get-started-building-on-Ethereum"><a href="#Get-started-building-on-Ethereum" class="headerlink" title="Get started building on Ethereum"></a>Get started building on Ethereum</h1><p>使用 <strong>Ethereum Studio</strong> , a web-based IDE.</p>
<p>在云端使用默认模板生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Specifies that the source code is for a version</span><br><span class="line">&#x2F;&#x2F; of Solidity greater than 0.5.10</span><br><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A contract is a collection of functions and data (its state)</span><br><span class="line">&#x2F;&#x2F; that resides at a specific address on the Ethereum blockchain.</span><br><span class="line">contract HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The keyword &quot;public&quot; makes variables accessible from outside a contract</span><br><span class="line">    &#x2F;&#x2F; and creates a function that other contracts or SDKs can call to access the value</span><br><span class="line">    string public message;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A special function only run during the creation of the contract</span><br><span class="line">    constructor(string memory initMessage) public &#123;</span><br><span class="line">        &#x2F;&#x2F; Takes a string value and stores the value in the memory data storage area,</span><br><span class="line">        &#x2F;&#x2F; setting &#96;message&#96; to that value</span><br><span class="line">        message &#x3D; initMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A publicly accessible function that takes a string as a parameter</span><br><span class="line">    &#x2F;&#x2F; and updates &#96;message&#96;</span><br><span class="line">    function update(string memory newMessage) public &#123;</span><br><span class="line">        message &#x3D; newMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击右侧的小火箭进行部署，程序就正常运行了。</p>
<blockquote>
<h1 id="Hello-World-template"><a href="#Hello-World-template" class="headerlink" title="Hello World template"></a>Hello World template</h1><p>This template is a “Hello World” example that teaches you how to:</p>
<ul>
<li>Provide arguments to a contract constructor using the <em>Configure contract</em> modal.</li>
<li>Store state in a contract and to update it.</li>
<li>Fetch your newly created contract’s information from the blockchain and render it to a front end.</li>
</ul>
<blockquote>
<p>Tutorial content supplied by <a href="https://kauri.io/" target="_blank" rel="noopener">kauri.io</a>.</p>
</blockquote>
<h2 id="Explanation-of-the-template"><a href="#Explanation-of-the-template" class="headerlink" title="Explanation of the template"></a>Explanation of the template</h2><h3 id="The-smart-contract"><a href="#The-smart-contract" class="headerlink" title="The smart contract"></a>The smart contract</h3><blockquote>
<p>Find the smart contract file in <em>contracts/HelloWorld.sol</em></p>
</blockquote>
<p>The first line, <code>pragma solidity ^0.5.10</code> specifies that the source code is for a Solidity version greater than 0.5.10. <a href="https://solidity.readthedocs.io/en/latest/layout-of-source-files.html#pragma" target="_blank" rel="noopener">Pragmas</a> are common instructions for compilers about how to treat the source code (e.g., pragma once).</p>
<p>A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. The line <code>string public message</code> declares a public state variable called <code>message</code> of type <code>string</code>. You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database. The keyword public automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable.</p>
<p>The <a href="https://solidity.readthedocs.io/en/latest/contracts.html#constructor" target="_blank" rel="noopener"><code>constructor</code></a> is a special function run during the creation of the contract and cannot be called afterward. In this case, it takes a string value <code>initMessage</code>, stores the value in the <a href="https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#storage-memory-and-the-stack" target="_blank" rel="noopener"><code>memory</code></a> data storage area, and sets <code>message</code> to that value.</p>
<p>The <code>update</code> function is another public function that is similar to the constructor, taking a string as a parameter, and updating the <code>message</code> variable.</p>
<h3 id="1-Configure"><a href="#1-Configure" class="headerlink" title="1. Configure"></a>1. Configure</h3><p>Configuring the contract allows you to set the name of the contract and the initial values sent to the constructor as arguments. You can configure the contract by going to the Deploy panel, accessed by clicking on the rocket icon in the left side menu and choosing <em>Configure</em> option. In this example, it configures the string displayed in the front end interface.</p>
<h3 id="2-Compile"><a href="#2-Compile" class="headerlink" title="2. Compile"></a>2. Compile</h3><p>Solidity is a compiled language, and you need to convert the Solidity code into bytecode before the contract can run. We will automatically compile the code every time you save your changes or when performing a deployment.</p>
<h3 id="3-Deploy"><a href="#3-Deploy" class="headerlink" title="3. Deploy"></a>3. Deploy</h3><p>Every smart contract runs at an address on the Ethereum blockchain, and you must deploy it to an address before it can run. When using Studio, the browser simulates the network, but there are several test networks and one main network for the Ethereum blockchain.</p>
<p>Deploy the contract by going to the <em>Deploy</em> panel, accessed by clicking on the rocket icon in the left side menu.</p>
</blockquote>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>Ethereum-Studio-Sample-Crypto-Pizzas</title>
    <url>/ethereum-studio-sample-crypto-pizzas/</url>
    <content><![CDATA[<h1 id="Creating-a-unique-collectible-token"><a href="#Creating-a-unique-collectible-token" class="headerlink" title="Creating a unique collectible token"></a>Creating a unique collectible token</h1><p>This project is an example application that teaches you how to:</p>
<ul>
<li>Write a smart contract and web app that conforms to a token standard.</li>
<li>Different variable types in Solidity.</li>
<li>Create, update and get variables in a smart contract.</li>
<li>Emit events that clients can subscribe to.</li>
<li>Provide arguments to a contract constructor using the <em>Configure contract</em> modal.</li>
</ul>
<p>这是一个略微复杂的智能合约</p>
<p><img data-src="/ethereum-studio-sample-crypto-pizzas/image-20200610200542158.png" alt="image-20200610200542158"></p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>Ethereum-Studio-Sample-Coin</title>
    <url>/ethereum-studio-sample-coin/</url>
    <content><![CDATA[<p>Ethereum-Studio 上面简单的 Coin 交易 Sample</p>
<p>代码很容易理解，重要的是基于这个代码理解了 Ethereum-Studio 上面的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Specifies that the source code is for a version</span></span><br><span class="line"><span class="comment">// of Solidity greater than 0.5.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A contract is a collection of functions and data (its state)</span></span><br><span class="line"><span class="comment">// that resides at a specific address on the Ethereum blockchain.</span></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    <span class="comment">// The keyword "public" makes variables accessible from outside a contract</span></span><br><span class="line">    <span class="comment">// and creates a function that other contracts or SDKs can call to access the value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// An address stores addresses of contracts or external (user) accounts</span></span><br><span class="line">    address public minter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A mapping lets you create complex custom data types.</span></span><br><span class="line">    <span class="comment">// This mapping assigns an unsigned integer to an address</span></span><br><span class="line">    <span class="comment">// and is also a public variable.</span></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Events allow Ethereum clients to react to specific</span></span><br><span class="line">    <span class="comment">// contract changes you declare.</span></span><br><span class="line">    <span class="comment">// This defines the event and it is sent later</span></span><br><span class="line">    event Sent(address <span class="keyword">from</span>, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A special function only run during the creation of the contract</span></span><br><span class="line">    <span class="keyword">constructor</span>() public &#123;</span><br><span class="line">        <span class="comment">// Uses the special msg global variable to store the</span></span><br><span class="line">        <span class="comment">// address of the contract creator</span></span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sends an amount of newly created coins to an address</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// require statements define conditions that must pass</span></span><br><span class="line">        <span class="comment">// before state is changed.</span></span><br><span class="line">        <span class="comment">// If it fails (equals false), an exception is triggered</span></span><br><span class="line">        <span class="comment">// and reverts all modifications to state from the current call</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can only be called by the contract creator</span></span><br><span class="line">        <span class="built_in">require</span>(msg.sender == minter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensures a maximum amount of tokens</span></span><br><span class="line">        <span class="built_in">require</span>(amount &lt; <span class="number">1e60</span>);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sends an amount of existing coins</span></span><br><span class="line">    <span class="comment">// from any caller to an address</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The sender must have enough coins to send</span></span><br><span class="line">        <span class="built_in">require</span>(amount &lt;= balances[msg.sender], <span class="string">"Insufficient balance."</span>);</span><br><span class="line">        <span class="comment">// Adjust balances</span></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        <span class="comment">// Emit event defined earlier</span></span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到页面默认是这样的</p>
<p><img data-src="/ethereum-studio-sample-coin/image-20200610194530891.png" alt="image-20200610194530891"></p>
<p>点击左侧的小火箭进行部署 - 右侧会更新 <code>构造函数</code> 生成的结果。</p>
<p><img data-src="/ethereum-studio-sample-coin/image-20200610194608028.png" alt="image-20200610194608028"></p>
<p>利用 mint 函数，为合约账户添加 100 个币。</p>
<p><img data-src="/ethereum-studio-sample-coin/image-20200610194743997.png" alt="image-20200610194743997"></p>
<p>给账户一转去 50 个币，可以看到交易和余额同步都正确显示了。</p>
<p><img data-src="/ethereum-studio-sample-coin/image-20200610194838920.png" alt="image-20200610194838920"></p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>Remix-Ballot-Demo</title>
    <url>/remix-ballot-demo/</url>
    <content><![CDATA[<p>这个合约进一步扩展了使用，同时最大的亮点是带 <code>test</code></p>
<h3 id="Ballot-sol"><a href="#Ballot-sol" class="headerlink" title="Ballot.sol"></a>Ballot.sol</h3><p>可以看到 constuctor 函数带了参数，在左侧同时也会预留出位置。</p>
<p><img data-src="/remix-ballot-demo/image-20200613182940216.png" alt="image-20200613182940216"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;&#x3D;0.4.22 &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * @title Ballot</span><br><span class="line"> * @dev Implements voting process along with vote delegation</span><br><span class="line"> *&#x2F;</span><br><span class="line">contract Ballot &#123;</span><br><span class="line">   </span><br><span class="line">    struct Voter &#123;</span><br><span class="line">        uint weight; &#x2F;&#x2F; weight is accumulated by delegation</span><br><span class="line">        bool voted;  &#x2F;&#x2F; if true, that person already voted</span><br><span class="line">        address delegate; &#x2F;&#x2F; person delegated to</span><br><span class="line">        uint vote;   &#x2F;&#x2F; index of the voted proposal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Proposal &#123;</span><br><span class="line">        &#x2F;&#x2F; If you can limit the length to a certain number of bytes, </span><br><span class="line">        &#x2F;&#x2F; always use one of bytes1 to bytes32 because they are much cheaper</span><br><span class="line">        bytes32 name;   &#x2F;&#x2F; short name (up to 32 bytes)</span><br><span class="line">        uint voteCount; &#x2F;&#x2F; number of accumulated votes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address public chairperson;</span><br><span class="line"></span><br><span class="line">    mapping(address &#x3D;&gt; Voter) public voters;</span><br><span class="line"></span><br><span class="line">    Proposal[] public proposals;</span><br><span class="line"></span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @dev Create a new ballot to choose one of &#39;proposalNames&#39;.</span><br><span class="line">     * @param proposalNames names of proposals</span><br><span class="line">     *&#x2F;</span><br><span class="line">    constructor(bytes32[] memory proposalNames) public &#123;</span><br><span class="line">        chairperson &#x3D; msg.sender;</span><br><span class="line">        voters[chairperson].weight &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        for (uint i &#x3D; 0; i &lt; proposalNames.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; &#39;Proposal(&#123;...&#125;)&#39; creates a temporary</span><br><span class="line">            &#x2F;&#x2F; Proposal object and &#39;proposals.push(...)&#39;</span><br><span class="line">            &#x2F;&#x2F; appends it to the end of &#39;proposals&#39;.</span><br><span class="line">            proposals.push(Proposal(&#123;</span><br><span class="line">                name: proposalNames[i],</span><br><span class="line">                voteCount: 0</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @dev Give &#39;voter&#39; the right to vote on this ballot. May only be called by &#39;chairperson&#39;.</span><br><span class="line">     * @param voter address of voter</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function giveRightToVote(address voter) public &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; chairperson,</span><br><span class="line">            &quot;Only chairperson can give right to vote.&quot;</span><br><span class="line">        );</span><br><span class="line">        require(</span><br><span class="line">            !voters[voter].voted,</span><br><span class="line">            &quot;The voter already voted.&quot;</span><br><span class="line">        );</span><br><span class="line">        require(voters[voter].weight &#x3D;&#x3D; 0);</span><br><span class="line">        voters[voter].weight &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @dev Delegate your vote to the voter &#39;to&#39;.</span><br><span class="line">     * @param to address to which vote is delegated</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function delegate(address to) public &#123;</span><br><span class="line">        Voter storage sender &#x3D; voters[msg.sender];</span><br><span class="line">        require(!sender.voted, &quot;You already voted.&quot;);</span><br><span class="line">        require(to !&#x3D; msg.sender, &quot;Self-delegation is disallowed.&quot;);</span><br><span class="line"></span><br><span class="line">        while (voters[to].delegate !&#x3D; address(0)) &#123;</span><br><span class="line">            to &#x3D; voters[to].delegate;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; We found a loop in the delegation, not allowed.</span><br><span class="line">            require(to !&#x3D; msg.sender, &quot;Found loop in delegation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sender.voted &#x3D; true;</span><br><span class="line">        sender.delegate &#x3D; to;</span><br><span class="line">        Voter storage delegate_ &#x3D; voters[to];</span><br><span class="line">        if (delegate_.voted) &#123;</span><br><span class="line">            &#x2F;&#x2F; If the delegate already voted,</span><br><span class="line">            &#x2F;&#x2F; directly add to the number of votes</span><br><span class="line">            proposals[delegate_.vote].voteCount +&#x3D; sender.weight;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If the delegate did not vote yet,</span><br><span class="line">            &#x2F;&#x2F; add to her weight.</span><br><span class="line">            delegate_.weight +&#x3D; sender.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @dev Give your vote (including votes delegated to you) to proposal &#39;proposals[proposal].name&#39;.</span><br><span class="line">     * @param proposal index of proposal in the proposals array</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function vote(uint proposal) public &#123;</span><br><span class="line">        Voter storage sender &#x3D; voters[msg.sender];</span><br><span class="line">        require(sender.weight !&#x3D; 0, &quot;Has no right to vote&quot;);</span><br><span class="line">        require(!sender.voted, &quot;Already voted.&quot;);</span><br><span class="line">        sender.voted &#x3D; true;</span><br><span class="line">        sender.vote &#x3D; proposal;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If &#39;proposal&#39; is out of the range of the array,</span><br><span class="line">        &#x2F;&#x2F; this will throw automatically and revert all</span><br><span class="line">        &#x2F;&#x2F; changes.</span><br><span class="line">        proposals[proposal].voteCount +&#x3D; sender.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @dev Computes the winning proposal taking all previous votes into account.</span><br><span class="line">     * @return winningProposal_ index of winning proposal in the proposals array</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function winningProposal() public view</span><br><span class="line">            returns (uint winningProposal_)</span><br><span class="line">    &#123;</span><br><span class="line">        uint winningVoteCount &#x3D; 0;</span><br><span class="line">        for (uint p &#x3D; 0; p &lt; proposals.length; p++) &#123;</span><br><span class="line">            if (proposals[p].voteCount &gt; winningVoteCount) &#123;</span><br><span class="line">                winningVoteCount &#x3D; proposals[p].voteCount;</span><br><span class="line">                winningProposal_ &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then</span><br><span class="line">     * @return winnerName_ the name of the winner</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function winnerName() public view</span><br><span class="line">            returns (bytes32 winnerName_)</span><br><span class="line">    &#123;</span><br><span class="line">        winnerName_ &#x3D; proposals[winningProposal()].name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="test-sol"><a href="#test-sol" class="headerlink" title="test.sol"></a>test.sol</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;&#x3D;0.4.22 &lt;0.7.0;</span><br><span class="line">import &quot;remix_tests.sol&quot;; &#x2F;&#x2F; this import is automatically injected by Remix.</span><br><span class="line">import &quot;.&#x2F;3_Ballot.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract BallotTest &#123;</span><br><span class="line">   </span><br><span class="line">    bytes32[] proposalNames;</span><br><span class="line">   </span><br><span class="line">    Ballot ballotToTest;</span><br><span class="line">    function beforeAll () public &#123;</span><br><span class="line">        proposalNames.push(bytes32(&quot;candidate1&quot;));</span><br><span class="line">        ballotToTest &#x3D; new Ballot(proposalNames);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function checkWinningProposal () public &#123;</span><br><span class="line">        ballotToTest.vote(0);</span><br><span class="line">        Assert.equal(ballotToTest.winningProposal(), uint(0), &quot;proposal at index 0 should be the winning proposal&quot;);</span><br><span class="line">        Assert.equal(ballotToTest.winnerName(), bytes32(&quot;candidate1&quot;), &quot;candidate1 should be the winner name&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function checkWinninProposalWithReturnValue () public view returns (bool) &#123;</span><br><span class="line">        return ballotToTest.winningProposal() &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>remix</tag>
      </tags>
  </entry>
  <entry>
    <title>Remix-Owner-Demo</title>
    <url>/remix-owner-demo/</url>
    <content><![CDATA[<p>这个智能合约增加了操作数和账户，的但是依旧是比较简单的合约。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;&#x3D;0.4.22 &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line"></span><br><span class="line">    address private owner;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; event for EVM logging</span><br><span class="line">    event OwnerSet(address indexed oldOwner, address indexed newOwner);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; modifier to check if caller is owner</span><br><span class="line">    modifier isOwner() &#123;</span><br><span class="line">        &#x2F;&#x2F; If the first argument of &#39;require&#39; evaluates to &#39;false&#39;, execution terminates and all</span><br><span class="line">        &#x2F;&#x2F; changes to the state and to Ether balances are reverted.</span><br><span class="line">        &#x2F;&#x2F; This used to consume all gas in old EVM versions, but not anymore.</span><br><span class="line">        &#x2F;&#x2F; It is often a good idea to use &#39;require&#39; to check if functions are called correctly.</span><br><span class="line">        &#x2F;&#x2F; As a second argument, you can also provide an explanation about what went wrong.</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner, &quot;Caller is not owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @dev Set contract deployer as owner</span><br><span class="line">     *&#x2F;</span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner &#x3D; msg.sender; &#x2F;&#x2F; &#39;msg.sender&#39; is sender of current call, contract deployer for a constructor</span><br><span class="line">        emit OwnerSet(address(0), owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @dev Change owner</span><br><span class="line">     * @param newOwner address of new owner</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function changeOwner(address newOwner) public isOwner &#123;</span><br><span class="line">        emit OwnerSet(owner, newOwner);</span><br><span class="line">        owner &#x3D; newOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @dev Return owner address </span><br><span class="line">     * @return address of owner</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function getOwner() external view returns (address) &#123;</span><br><span class="line">        return owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/remix-owner-demo/image-20200613182526375.png" alt="image-20200613182526375"></p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>remix</tag>
      </tags>
  </entry>
  <entry>
    <title>Remix-Storage-Demo</title>
    <url>/remix-storage-demo/</url>
    <content><![CDATA[<p>第一个例子很简单，简单的代码，学习一下操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;&#x3D;0.4.22 &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @title Storage</span><br><span class="line"> * @dev Store &amp; retreive value in a variable</span><br><span class="line"> *&#x2F;</span><br><span class="line">contract Storage &#123;</span><br><span class="line"></span><br><span class="line">    uint256 number;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @dev Store value in variable</span><br><span class="line">     * @param num value to store</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function store(uint256 num) public &#123;</span><br><span class="line">        number &#x3D; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @dev Return value </span><br><span class="line">     * @return value of &#39;number&#39;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function retreive() public view returns (uint256)&#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/remix-storage-demo/image-20200613182040528.png" alt="image-20200613182040528"></p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>remix</tag>
      </tags>
  </entry>
  <entry>
    <title>心疼我的Ethereum Studio</title>
    <url>/ethereum-studio-no-longer-support/</url>
    <content><![CDATA[<p><img data-src="/ethereum-studio-no-longer-support/image-20200613174400940.png" alt="image-20200613174400940"></p>
<p>突然发现我最爱的 <code>Ethereum Studio</code> 被列为了之后不再维护的 IDE，心痛。。。</p>
<p>今天接下来的主要任务就是对着官网链接整体过一下 Solidity 语法和 Remix 的使用！</p>
<p><img data-src="/ethereum-studio-no-longer-support/image-20200614083819767.png" alt="image-20200614083819767"></p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity-Official-Demo-安全的远程购买</title>
    <url>/solidity-official-demo-safely-remote-shopping/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    uint public value;</span><br><span class="line">    address public seller;</span><br><span class="line">    address public buyer;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125;</span><br><span class="line">    State public state;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确保 &#96;msg.value&#96; 是一个偶数。</span><br><span class="line">    &#x2F;&#x2F;如果它是一个奇数，则它将被截断。</span><br><span class="line">    &#x2F;&#x2F;通过乘法检查它不是奇数。</span><br><span class="line">    constructor() public payable &#123;</span><br><span class="line">        seller &#x3D; msg.sender;</span><br><span class="line">        value &#x3D; msg.value &#x2F; 2;</span><br><span class="line">        require((2 * value) &#x3D;&#x3D; msg.value, &quot;Value has to be even.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier condition(bool _condition) &#123;</span><br><span class="line">        require(_condition);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyBuyer() &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; buyer,</span><br><span class="line">            &quot;Only buyer can call this.&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; seller,</span><br><span class="line">            &quot;Only seller can call this.&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier inState(State _state) &#123;</span><br><span class="line">        require(</span><br><span class="line">            state &#x3D;&#x3D; _state,</span><br><span class="line">            &quot;Invalid state.&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Aborted();</span><br><span class="line">    event PurchaseConfirmed();</span><br><span class="line">    event ItemReceived();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F;中止购买并回收以太币。</span><br><span class="line">    &#x2F;&#x2F;&#x2F;只能在合约被锁定之前由卖家调用。</span><br><span class="line">    function abort()</span><br><span class="line">        public</span><br><span class="line">        onlySeller</span><br><span class="line">        inState(State.Created)</span><br><span class="line">    &#123;</span><br><span class="line">        emit Aborted();</span><br><span class="line">        state &#x3D; State.Inactive;</span><br><span class="line">        seller.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 买家确认购买。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 交易必须包含 &#96;2 * value&#96; 个以太币。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 以太币会被锁定，直到 confirmReceived 被调用。</span><br><span class="line">    function confirmPurchase()</span><br><span class="line">        public</span><br><span class="line">        inState(State.Created)</span><br><span class="line">        condition(msg.value &#x3D;&#x3D; (2 * value))</span><br><span class="line">        payable</span><br><span class="line">    &#123;</span><br><span class="line">        emit PurchaseConfirmed();</span><br><span class="line">        buyer &#x3D; msg.sender;</span><br><span class="line">        state &#x3D; State.Locked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 确认你（买家）已经收到商品。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 这会释放被锁定的以太币。</span><br><span class="line">    function confirmReceived()</span><br><span class="line">        public</span><br><span class="line">        onlyBuyer</span><br><span class="line">        inState(State.Locked)</span><br><span class="line">    &#123;</span><br><span class="line">        emit ItemReceived();</span><br><span class="line">        &#x2F;&#x2F; 首先修改状态很重要，否则的话，由 &#96;transfer&#96; 所调用的合约可以回调进这里（再次接收以太币）。</span><br><span class="line">        state &#x3D; State.Inactive;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 注意: 这实际上允许买方和卖方阻止退款 - 应该使用取回模式。</span><br><span class="line">        buyer.transfer(value);</span><br><span class="line">        seller.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>sublime安装solidity代码高亮</title>
    <url>/sublime-solidity-highlight/</url>
    <content><![CDATA[<h3 id="安装-Package-Control"><a href="#安装-Package-Control" class="headerlink" title="安装 Package Control"></a>安装 Package Control</h3><p>通过 Ctrl+<code>快捷键或者</code>View &gt; Show Console` 菜单打开控制台，复制粘贴如下代码回车即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h &#x3D; &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by &#x3D; urllib.request.urlopen( &#39;http:&#x2F;&#x2F;packagecontrol.io&#x2F;&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh &#x3D; hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh !&#x3D; h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</span><br></pre></td></tr></table></figure>

<h3 id="在-Preference-中打开-Package-Control"><a href="#在-Preference-中打开-Package-Control" class="headerlink" title="在 Preference 中打开 Package-Control"></a>在 Preference 中打开 Package-Control</h3><p><img data-src="/sublime-solidity-highlight/image-20200613094916993.png" alt="image-20200613094916993"></p>
<h3 id="在-Package-Control-中搜索-install-package"><a href="#在-Package-Control-中搜索-install-package" class="headerlink" title="在 Package Control 中搜索 install package"></a>在 Package Control 中搜索 install package</h3><p>左下角会有一个加载的提示</p>
<p><img data-src="/sublime-solidity-highlight/image-20200613095119124.png" alt="image-20200613095119124"></p>
<h3 id="在弹出的搜索栏中输入-Ethereum"><a href="#在弹出的搜索栏中输入-Ethereum" class="headerlink" title="在弹出的搜索栏中输入 Ethereum"></a>在弹出的搜索栏中输入 Ethereum</h3><p>点击安装即可</p>
<h3 id="重启-sublime-就可以看到代码高亮了"><a href="#重启-sublime-就可以看到代码高亮了" class="headerlink" title="重启 sublime 就可以看到代码高亮了"></a>重启 sublime 就可以看到代码高亮了</h3><p><img data-src="/sublime-solidity-highlight/image-20200613095354818.png" alt="image-20200613095354818"></p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity Official Demo-投票</title>
    <url>/solidity-official-demo-vote/</url>
    <content><![CDATA[<h2 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h2><p>以下的合约相当复杂，但展示了很多Solidity的功能。它实现了一个投票合约。 当然，电子投票的主要问题是如何将投票权分配给正确的人员以及如何防止被操纵。 在这里解决所有的问题，但会展示如何进行委托投票，同时，计票又是 <strong>自动和完全透明的</strong> 。</p>
<p>想法是为每个（投票）表决创建一份合约，为每个选项提供简称。 然后作为合约的创造者——即主席，将给予每个独立的地址以投票权。</p>
<p>地址后面的人可以选择自己投票，或者委托给他们信任的人来投票。</p>
<p>在投票时间结束时，<code>winningProposal()</code> 将返回获得最多投票的提案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @title 委托投票</span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里声明了一个新的复合类型用于稍后的变量</span><br><span class="line">    &#x2F;&#x2F; 它用来表示一个选民</span><br><span class="line">    struct Voter &#123;</span><br><span class="line">        uint weight; &#x2F;&#x2F; 计票的权重</span><br><span class="line">        bool voted;  &#x2F;&#x2F; 若为真，代表该人已投票</span><br><span class="line">        address delegate; &#x2F;&#x2F; 被委托人</span><br><span class="line">        uint vote;   &#x2F;&#x2F; 投票提案的索引</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提案的类型</span><br><span class="line">    struct Proposal &#123;</span><br><span class="line">        bytes32 name;   &#x2F;&#x2F; 简称（最长32个字节）</span><br><span class="line">        uint voteCount; &#x2F;&#x2F; 得票数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address public chairperson;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这声明了一个状态变量，为每个可能的地址存储一个 &#96;Voter&#96;。</span><br><span class="line">    mapping(address &#x3D;&gt; Voter) public voters;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 一个 &#96;Proposal&#96; 结构类型的动态数组</span><br><span class="line">    Proposal[] public proposals;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 为 &#96;proposalNames&#96; 中的每个提案，创建一个新的（投票）表决</span><br><span class="line">    constructor(bytes32[] proposalNames) public &#123;</span><br><span class="line">        chairperson &#x3D; msg.sender;</span><br><span class="line">        voters[chairperson].weight &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F;对于提供的每个提案名称，</span><br><span class="line">        &#x2F;&#x2F;创建一个新的 Proposal 对象并把它添加到数组的末尾。</span><br><span class="line">        for (uint i &#x3D; 0; i &lt; proposalNames.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; &#96;Proposal(&#123;...&#125;)&#96; 创建一个临时 Proposal 对象，</span><br><span class="line">            &#x2F;&#x2F; &#96;proposals.push(...)&#96; 将其添加到 &#96;proposals&#96; 的末尾</span><br><span class="line">            proposals.push(Proposal(&#123;</span><br><span class="line">                name: proposalNames[i],</span><br><span class="line">                voteCount: 0</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 授权 &#96;voter&#96; 对这个（投票）表决进行投票</span><br><span class="line">    &#x2F;&#x2F; 只有 &#96;chairperson&#96; 可以调用该函数。</span><br><span class="line">    function giveRightToVote(address voter) public &#123;</span><br><span class="line">        &#x2F;&#x2F; 若 &#96;require&#96; 的第一个参数的计算结果为 &#96;false&#96;，</span><br><span class="line">        &#x2F;&#x2F; 则终止执行，撤销所有对状态和以太币余额的改动。</span><br><span class="line">        &#x2F;&#x2F; 在旧版的 EVM 中这曾经会消耗所有 gas，但现在不会了。</span><br><span class="line">        &#x2F;&#x2F; 使用 require 来检查函数是否被正确地调用，是一个好习惯。</span><br><span class="line">        &#x2F;&#x2F; 你也可以在 require 的第二个参数中提供一个对错误情况的解释。</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; chairperson,</span><br><span class="line">            &quot;Only chairperson can give right to vote.&quot;</span><br><span class="line">        );</span><br><span class="line">        require(</span><br><span class="line">            !voters[voter].voted,</span><br><span class="line">            &quot;The voter already voted.&quot;</span><br><span class="line">        );</span><br><span class="line">        require(voters[voter].weight &#x3D;&#x3D; 0);</span><br><span class="line">        voters[voter].weight &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 把你的投票委托到投票者 &#96;to&#96;。</span><br><span class="line">    function delegate(address to) public &#123;</span><br><span class="line">        &#x2F;&#x2F; 传引用</span><br><span class="line">        Voter storage sender &#x3D; voters[msg.sender];</span><br><span class="line">        require(!sender.voted, &quot;You already voted.&quot;);</span><br><span class="line"></span><br><span class="line">        require(to !&#x3D; msg.sender, &quot;Self-delegation is disallowed.&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 委托是可以传递的，只要被委托者 &#96;to&#96; 也设置了委托。</span><br><span class="line">        &#x2F;&#x2F; 一般来说，这种循环委托是危险的。因为，如果传递的链条太长，</span><br><span class="line">        &#x2F;&#x2F; 则可能需消耗的gas要多于区块中剩余的（大于区块设置的gasLimit），</span><br><span class="line">        &#x2F;&#x2F; 这种情况下，委托不会被执行。</span><br><span class="line">        &#x2F;&#x2F; 而在另一些情况下，如果形成闭环，则会让合约完全卡住。</span><br><span class="line">        while (voters[to].delegate !&#x3D; address(0)) &#123;</span><br><span class="line">            to &#x3D; voters[to].delegate;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 不允许闭环委托</span><br><span class="line">            require(to !&#x3D; msg.sender, &quot;Found loop in delegation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; &#96;sender&#96; 是一个引用, 相当于对 &#96;voters[msg.sender].voted&#96; 进行修改</span><br><span class="line">        sender.voted &#x3D; true;</span><br><span class="line">        sender.delegate &#x3D; to;</span><br><span class="line">        Voter storage delegate_ &#x3D; voters[to];</span><br><span class="line">        if (delegate_.voted) &#123;</span><br><span class="line">            &#x2F;&#x2F; 若被委托者已经投过票了，直接增加得票数</span><br><span class="line">            proposals[delegate_.vote].voteCount +&#x3D; sender.weight;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 若被委托者还没投票，增加委托者的权重</span><br><span class="line">            delegate_.weight +&#x3D; sender.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 把你的票(包括委托给你的票)，</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 投给提案 &#96;proposals[proposal].name&#96;.</span><br><span class="line">    function vote(uint proposal) public &#123;</span><br><span class="line">        Voter storage sender &#x3D; voters[msg.sender];</span><br><span class="line">        require(!sender.voted, &quot;Already voted.&quot;);</span><br><span class="line">        sender.voted &#x3D; true;</span><br><span class="line">        sender.vote &#x3D; proposal;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 &#96;proposal&#96; 超过了数组的范围，则会自动抛出异常，并恢复所有的改动</span><br><span class="line">        proposals[proposal].voteCount +&#x3D; sender.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @dev 结合之前所有的投票，计算出最终胜出的提案</span><br><span class="line">    function winningProposal() public view</span><br><span class="line">            returns (uint winningProposal_)</span><br><span class="line">    &#123;</span><br><span class="line">        uint winningVoteCount &#x3D; 0;</span><br><span class="line">        for (uint p &#x3D; 0; p &lt; proposals.length; p++) &#123;</span><br><span class="line">            if (proposals[p].voteCount &gt; winningVoteCount) &#123;</span><br><span class="line">                winningVoteCount &#x3D; proposals[p].voteCount;</span><br><span class="line">                winningProposal_ &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称</span><br><span class="line">    function winnerName() public view</span><br><span class="line">            returns (bytes32 winnerName_)</span><br><span class="line">    &#123;</span><br><span class="line">        winnerName_ &#x3D; proposals[winningProposal()].name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>Solidity-Official-Demo-秘密竞拍（盲拍）</title>
    <url>/solidity-official-demo-secret-auction/</url>
    <content><![CDATA[<h3 id="秘密竞拍（盲拍）"><a href="#秘密竞拍（盲拍）" class="headerlink" title="秘密竞拍（盲拍）"></a>秘密竞拍（盲拍）</h3><p>之前的公开拍卖接下来将被扩展为一个秘密竞拍。 秘密竞拍的好处是在投标结束前不会有时间压力。 在一个透明的计算平台上进行秘密竞拍听起来像是自相矛盾，但密码学可以实现它。</p>
<p>在 <strong>投标期间</strong> ，投标人实际上并没有发送她的出价，而只是发送一个哈希版本的出价。 由于目前几乎不可能找到两个（足够长的）值，其哈希值是相等的，因此投标人可通过该方式提交报价。 在投标结束后，投标人必须公开他们的出价：他们不加密的发送他们的出价，合约检查出价的哈希值是否与投标期间提供的相同。</p>
<p>另一个挑战是如何使拍卖同时做到 <strong>绑定和秘密</strong> : 唯一能阻止投标者在她赢得拍卖后不付款的方式是，让她将钱连同出价一起发出。 但由于资金转移在 以太坊Ethereum 中不能被隐藏，因此任何人都可以看到转移的资金。</p>
<p>下面的合约通过接受任何大于最高出价的值来解决这个问题。 当然，因为这只能在披露阶段进行检查，有些出价可能是 <strong>无效</strong> 的， 并且，这是故意的(与高出价一起，它甚至提供了一个明确的标志来标识无效的出价): 投标人可以通过设置几个或高或低的无效出价来迷惑竞争对手。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;0.4.23 &lt;0.5.0;</span><br><span class="line"></span><br><span class="line">contract BlindAuction &#123;</span><br><span class="line">    struct Bid &#123;</span><br><span class="line">        bytes32 blindedBid;</span><br><span class="line">        uint deposit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address public beneficiary;</span><br><span class="line">    uint public biddingEnd;</span><br><span class="line">    uint public revealEnd;</span><br><span class="line">    bool public ended;</span><br><span class="line"></span><br><span class="line">    mapping(address &#x3D;&gt; Bid[]) public bids;</span><br><span class="line"></span><br><span class="line">    address public highestBidder;</span><br><span class="line">    uint public highestBid;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 可以取回的之前的出价</span><br><span class="line">    mapping(address &#x3D;&gt; uint) pendingReturns;</span><br><span class="line"></span><br><span class="line">    event AuctionEnded(address winner, uint highestBid);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 使用 modifier 可以更便捷的校验函数的入参。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &#96;onlyBefore&#96; 会被用于后面的 &#96;bid&#96; 函数：</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 新的函数体是由 modifier 本身的函数体，并用原函数体替换 &#96;_;&#96; 语句来组成的。</span><br><span class="line">    modifier onlyBefore(uint _time) &#123; require(now &lt; _time); _; &#125;</span><br><span class="line">    modifier onlyAfter(uint _time) &#123; require(now &gt; _time); _; &#125;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        uint _biddingTime,</span><br><span class="line">        uint _revealTime,</span><br><span class="line">        address _beneficiary</span><br><span class="line">    ) public &#123;</span><br><span class="line">        beneficiary &#x3D; _beneficiary;</span><br><span class="line">        biddingEnd &#x3D; now + _biddingTime;</span><br><span class="line">        revealEnd &#x3D; biddingEnd + _revealTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 可以通过 &#96;_blindedBid&#96; &#x3D; keccak256(value, fake, secret)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 设置一个秘密竞拍。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 只有在出价披露阶段被正确披露，已发送的以太币才会被退还。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 如果与出价一起发送的以太币至少为 “value” 且 “fake” 不为真，则出价有效。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 将 “fake” 设置为 true ，然后发送满足订金金额但又不与出价相同的金额是隐藏实际出价的方法。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 同一个地址可以放置多个出价。</span><br><span class="line">    function bid(bytes32 _blindedBid)</span><br><span class="line">        public</span><br><span class="line">        payable</span><br><span class="line">        onlyBefore(biddingEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        bids[msg.sender].push(Bid(&#123;</span><br><span class="line">            blindedBid: _blindedBid,</span><br><span class="line">            deposit: msg.value</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 披露你的秘密竞拍出价。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 对于所有正确披露的无效出价以及除最高出价以外的所有出价，你都将获得退款。</span><br><span class="line">    function reveal(</span><br><span class="line">        uint[] _values,</span><br><span class="line">        bool[] _fake,</span><br><span class="line">        bytes32[] _secret</span><br><span class="line">    )</span><br><span class="line">        public</span><br><span class="line">        onlyAfter(biddingEnd)</span><br><span class="line">        onlyBefore(revealEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        uint length &#x3D; bids[msg.sender].length;</span><br><span class="line">        require(_values.length &#x3D;&#x3D; length);</span><br><span class="line">        require(_fake.length &#x3D;&#x3D; length);</span><br><span class="line">        require(_secret.length &#x3D;&#x3D; length);</span><br><span class="line"></span><br><span class="line">        uint refund;</span><br><span class="line">        for (uint i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            Bid storage bid &#x3D; bids[msg.sender][i];</span><br><span class="line">            (uint value, bool fake, bytes32 secret) &#x3D;</span><br><span class="line">                    (_values[i], _fake[i], _secret[i]);</span><br><span class="line">            if (bid.blindedBid !&#x3D; keccak256(value, fake, secret)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 出价未能正确披露</span><br><span class="line">                &#x2F;&#x2F; 不返还订金</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            refund +&#x3D; bid.deposit;</span><br><span class="line">            if (!fake &amp;&amp; bid.deposit &gt;&#x3D; value) &#123;</span><br><span class="line">                if (placeBid(msg.sender, value))</span><br><span class="line">                    refund -&#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 使发送者不可能再次认领同一笔订金</span><br><span class="line">            bid.blindedBid &#x3D; bytes32(0);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.sender.transfer(refund);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是一个 &quot;internal&quot; 函数， 意味着它只能在本合约（或继承合约）内被调用</span><br><span class="line">    function placeBid(address bidder, uint value) internal</span><br><span class="line">            returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value &lt;&#x3D; highestBid) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (highestBidder !&#x3D; address(0)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 返还之前的最高出价</span><br><span class="line">            pendingReturns[highestBidder] +&#x3D; highestBid;</span><br><span class="line">        &#125;</span><br><span class="line">        highestBid &#x3D; value;</span><br><span class="line">        highestBidder &#x3D; bidder;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取回出价（当该出价已被超越）</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amount &#x3D; pendingReturns[msg.sender];</span><br><span class="line">        if (amount &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里很重要，首先要设零值。</span><br><span class="line">            &#x2F;&#x2F; 因为，作为接收调用的一部分，</span><br><span class="line">            &#x2F;&#x2F; 接收者可以在 &#96;transfer&#96; 返回之前重新调用该函数。（可查看上面关于‘条件 -&gt; 影响 -&gt; 交互’的标注）</span><br><span class="line">            pendingReturns[msg.sender] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">            msg.sender.transfer(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束拍卖，并把最高的出价发送给受益人</span><br><span class="line">    function auctionEnd()</span><br><span class="line">        public</span><br><span class="line">        onlyAfter(revealEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        require(!ended);</span><br><span class="line">        emit AuctionEnded(highestBidder, highestBid);</span><br><span class="line">        ended &#x3D; true;</span><br><span class="line">        beneficiary.transfer(highestBid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>1-搭建僵尸工厂</title>
    <url>/solidity-course-1-build-zoombies-factory/</url>
    <content><![CDATA[<h3 id="这是-Solidity-的游戏教学项目，非常好！"><a href="#这是-Solidity-的游戏教学项目，非常好！" class="headerlink" title="这是 Solidity 的游戏教学项目，非常好！"></a>这是 Solidity 的游戏教学项目，非常好！</h3><p><a href="https://cryptozombies.io/zh/course" target="_blank" rel="noopener">项目网址</a>，我也生成了自己的 hanwen <a href="https://share.cryptozombies.io/zh/lesson/1/share/hanwen" target="_blank" rel="noopener">zoombie</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits &#x3D; 16;</span><br><span class="line">    uint dnaModulus &#x3D; 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">        uint id &#x3D; zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand &#x3D; uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        uint randDna &#x3D; _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记录几个要点"><a href="#记录几个要点" class="headerlink" title="记录几个要点"></a>记录几个要点</h3><ol>
<li>创建函数的时候默认是 public</li>
<li>private 需要显式声明</li>
<li>returns 需要有 s</li>
<li>private 函数名需要以下环线开头</li>
<li><code>keccak256</code> 生成的是 256 位的十六进制的哈希值，需要进行 uint 转换</li>
</ol>
<h3 id="event-和-前端的监听"><a href="#event-和-前端的监听" class="headerlink" title="event 和 前端的监听"></a>event 和 前端的监听</h3><p>智能合约中初始化 event，并且在函数中调用这个 event 可以将对应的信息传递到 前端页面中。</p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity-Official-Demo-简单的公开拍卖</title>
    <url>/solidity-official-demo-simple-auction/</url>
    <content><![CDATA[<h3 id="简单的公开拍卖"><a href="#简单的公开拍卖" class="headerlink" title="简单的公开拍卖"></a>简单的公开拍卖</h3><p>以下简单的拍卖合约的总体思路是每个人都可以在投标期内发送他们的出价。 出价已经包含了资金/以太币，来将投标人与他们的投标绑定。 如果最高出价提高了（被其他出价者的出价超过），之前出价最高的出价者可以拿回她的钱。 在投标期结束后，受益人需要手动调用合约来接收他的钱 - 合约不能自己激活接收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    &#x2F;&#x2F; 拍卖的参数。</span><br><span class="line">    address public beneficiary;</span><br><span class="line">    &#x2F;&#x2F; 时间是unix的绝对时间戳（自1970-01-01以来的秒数）</span><br><span class="line">    &#x2F;&#x2F; 或以秒为单位的时间段。</span><br><span class="line">    uint public auctionEnd;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拍卖的当前状态</span><br><span class="line">    address public highestBidder;</span><br><span class="line">    uint public highestBid;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;可以取回的之前的出价</span><br><span class="line">    mapping(address &#x3D;&gt; uint) pendingReturns;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拍卖结束后设为 true，将禁止所有的变更</span><br><span class="line">    bool ended;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 变更触发的事件</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount);</span><br><span class="line">    event AuctionEnded(address winner, uint amount);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下是所谓的 natspec 注释，可以通过三个斜杠来识别。</span><br><span class="line">    &#x2F;&#x2F; 当用户被要求确认交易时将显示。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 以受益者地址 &#96;_beneficiary&#96; 的名义，</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 创建一个简单的拍卖，拍卖时间为 &#96;_biddingTime&#96; 秒。</span><br><span class="line">    constructor(</span><br><span class="line">        uint _biddingTime,</span><br><span class="line">        address _beneficiary</span><br><span class="line">    ) public &#123;</span><br><span class="line">        beneficiary &#x3D; _beneficiary;</span><br><span class="line">        auctionEnd &#x3D; now + _biddingTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 对拍卖进行出价，具体的出价随交易一起发送。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 如果没有在拍卖中胜出，则返还出价。</span><br><span class="line">    function bid() public payable &#123;</span><br><span class="line">        &#x2F;&#x2F; 参数不是必要的。因为所有的信息已经包含在了交易中。</span><br><span class="line">        &#x2F;&#x2F; 对于能接收以太币的函数，关键字 payable 是必须的。</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果拍卖已结束，撤销函数的调用。</span><br><span class="line">        require(</span><br><span class="line">            now &lt;&#x3D; auctionEnd,</span><br><span class="line">            &quot;Auction already ended.&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果出价不够高，返还你的钱</span><br><span class="line">        require(</span><br><span class="line">            msg.value &gt; highestBid,</span><br><span class="line">            &quot;There already is a higher bid.&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        if (highestBid !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 返还出价时，简单地直接调用 highestBidder.send(highestBid) 函数，</span><br><span class="line">            &#x2F;&#x2F; 是有安全风险的，因为它有可能执行一个非信任合约。</span><br><span class="line">            &#x2F;&#x2F; 更为安全的做法是让接收方自己提取金钱。</span><br><span class="line">            pendingReturns[highestBidder] +&#x3D; highestBid;</span><br><span class="line">        &#125;</span><br><span class="line">        highestBidder &#x3D; msg.sender;</span><br><span class="line">        highestBid &#x3D; msg.value;</span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取回出价（当该出价已被超越）</span><br><span class="line">    function withdraw() public returns (bool) &#123;</span><br><span class="line">        uint amount &#x3D; pendingReturns[msg.sender];</span><br><span class="line">        if (amount &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里很重要，首先要设零值。</span><br><span class="line">            &#x2F;&#x2F; 因为，作为接收调用的一部分，</span><br><span class="line">            &#x2F;&#x2F; 接收者可以在 &#96;send&#96; 返回之前，重新调用该函数。</span><br><span class="line">            pendingReturns[msg.sender] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">            if (!msg.sender.send(amount)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里不需抛出异常，只需重置未付款</span><br><span class="line">                pendingReturns[msg.sender] &#x3D; amount;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束拍卖，并把最高的出价发送给受益人</span><br><span class="line">    function auctionEnd() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币），</span><br><span class="line">        &#x2F;&#x2F; 一个好的指导方针是将其结构分为三个阶段：</span><br><span class="line">        &#x2F;&#x2F; 1. 检查条件</span><br><span class="line">        &#x2F;&#x2F; 2. 执行动作 (可能会改变条件)</span><br><span class="line">        &#x2F;&#x2F; 3. 与其他合约交互</span><br><span class="line">        &#x2F;&#x2F; 如果这些阶段相混合，其他的合约可能会回调当前合约并修改状态，</span><br><span class="line">        &#x2F;&#x2F; 或者导致某些效果（比如支付以太币）多次生效。</span><br><span class="line">        &#x2F;&#x2F; 如果合约内调用的函数包含了与外部合约的交互，</span><br><span class="line">        &#x2F;&#x2F; 则它也会被认为是与外部合约有交互的。</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1. 条件</span><br><span class="line">        require(now &gt;&#x3D; auctionEnd, &quot;Auction not yet ended.&quot;);</span><br><span class="line">        require(!ended, &quot;auctionEnd has already been called.&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 生效</span><br><span class="line">        ended &#x3D; true;</span><br><span class="line">        emit AuctionEnded(highestBidder, highestBid);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 交互</span><br><span class="line">        beneficiary.transfer(highestBid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>2-僵尸攻击人类</title>
    <url>/solidity-course-2-zombie-attack-human/</url>
    <content><![CDATA[<p>完成了教程，获得了 <a href="https://share.cryptozombies.io/zh/lesson/2/share/hanwen" target="_blank" rel="noopener">二级的僵尸</a>。</p>
<h3 id="记录几个要点"><a href="#记录几个要点" class="headerlink" title="记录几个要点"></a>记录几个要点</h3><ol>
<li><p><code>msg.sender</code> 调用者的地址</p>
</li>
<li><p>solidity 不原生支持字符串的比较</p>
<p><code>require(keccak256(_name) == keccak256(&quot;Vitalik&quot;));</code></p>
</li>
<li><p>继承关系存在（越来越感觉像 C++ 了）</p>
</li>
<li><p>多文件 <code>import</code> 语句需要添加分号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;.&#x2F;zombiefactory.sol&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数内部需要显式声明 <code>memory</code> <code>storage</code></p>
</li>
<li><p>合约不能调用另一个合约的 private 函数</p>
</li>
<li><p>在 Solidity中，可以让一个函数返回多个值</p>
</li>
</ol>
<h3 id="Contract-Interface"><a href="#Contract-Interface" class="headerlink" title="Contract Interface"></a>Contract Interface</h3><p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong><em>interface\</em></strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p>
<p>首先，我们只声明了要与之交互的函数 —— 在本例中为 <code>getNum</code> —— 在其中我们没有使用到任何其他的函数或状态变量。</p>
<p>其次，我们并没有使用大括号（<code>{</code> 和 <code>}</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p>
<p>编译器就是靠这些特征认出它是一个接口的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要写上所有的 return 的值，并且在 return 的括号后面加上分号！</p>
<p><strong>调用另一个合约</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract MyContract &#123;</span><br><span class="line">  address NumberInterfaceAddress &#x3D; 0xab38...;</span><br><span class="line">  &#x2F;&#x2F; ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract &#x3D; NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  &#x2F;&#x2F; 现在变量 &#96;numberContract&#96; 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public &#123;</span><br><span class="line">    &#x2F;&#x2F; 现在我们可以调用在那个合约中声明的 &#96;getNum&#96;函数:</span><br><span class="line">    uint num &#x3D; numberContract.getNum(msg.sender);</span><br><span class="line">    &#x2F;&#x2F; ...在这儿使用 &#96;num&#96;变量做些什么</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>3-高级Solidity理论</title>
    <url>/solidity-course-3-senior-theory/</url>
    <content><![CDATA[<p>实现了我的 <a href="https://share.cryptozombies.io/zh/lesson/3/share/hanwen" target="_blank" rel="noopener">三级僵尸</a>。</p>
<h3 id="回顾一下："><a href="#回顾一下：" class="headerlink" title="回顾一下："></a>回顾一下：</h3><ul>
<li>添加了一种新方法来修改CryptoKitties合约</li>
<li>学会使用 <code>onlyOwner</code> 进行调用权限限制</li>
<li>了解了 gas 和 gas 的优化</li>
<li>为僵尸添加了 “级别” 和 “冷却周期”属性</li>
<li>当僵尸达到一定级别时，允许修改僵尸的名字和 DNA</li>
<li>最后，定义了一个函数，用以返回某个玩家的僵尸军团</li>
</ul>
<h2 id="OpenZeppelin库的Ownable-合约"><a href="#OpenZeppelin库的Ownable-合约" class="headerlink" title="OpenZeppelin库的Ownable 合约"></a>OpenZeppelin库的<code>Ownable</code> 合约</h2><p>下面是一个 <code>Ownable</code> 合约的例子： 来自 <strong>_ OpenZeppelin _</strong> Solidity 库的 <code>Ownable</code> 合约。OpenZeppelin 是主打安保和社区审查的智能合约库，可以在自己的 DApps中引用。</p>
<h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><p>函数修饰符看起来跟函数没什么不同，不过关键字<code>modifier</code> 告诉编译器，这是个<code>modifier(修饰符)</code>，而不是个<code>function(函数)</code>。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p>
<p>咱们仔细读读 <code>onlyOwner</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @dev 调用者不是‘主人’，就会抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">  require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onlyOwner</code> 函数修饰符是这么用的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;注意！ &#96;onlyOwner&#96;上场 :</span><br><span class="line">  function likeABoss() external onlyOwner &#123;</span><br><span class="line">    LaughManiacally(&quot;Muahahahaha&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>likeABoss</code> 函数上的 <code>onlyOwner</code> 修饰符。 当你调用 <code>likeABoss</code> 时，<strong>首先执行</strong> <code>onlyOwner</code> 中的代码， 执行到 <code>onlyOwner</code> 中的 <code>_;</code> 语句时，程序再返回并执行 <code>likeABoss</code> 中的代码。</p>
<p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 <code>require</code>检查。</p>
<p>因为给函数添加了修饰符 <code>onlyOwner</code>，使得<strong>唯有合约的主人</strong>（也就是部署者）才能调用它。</p>
<h2 id="省-gas-的招数：结构封装-（Struct-packing）"><a href="#省-gas-的招数：结构封装-（Struct-packing）" class="headerlink" title="省 gas 的招数：结构封装 （Struct packing）"></a>省 gas 的招数：结构封装 （Struct packing）</h2><p>在第1课中，我们提到除了基本版的 <code>uint</code> 外，还有其他变种 <code>uint</code>：<code>uint8</code>，<code>uint16</code>，<code>uint32</code>等。</p>
<p>通常情况下我们不会考虑使用 <code>uint</code> 变种，因为无论如何定义 <code>uint</code>的大小，Solidity 为它保留256位的存储空间。例如，使用 <code>uint8</code> 而不是<code>uint</code>（<code>uint256</code>）不会为你节省任何 gas。</p>
<p>除非，把 <code>uint</code> 绑定到 <code>struct</code> 里面。</p>
<p>如果一个 <code>struct</code> 中有多个 <code>uint</code>，则尽可能使用较小的 <code>uint</code>, Solidity 会将这些 <code>uint</code> 打包在一起，从而占用较少的存储空间。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NormalStruct &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MiniMe &#123;</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因为使用了结构打包，&#96;mini&#96; 比 &#96;normal&#96; 占用的空间更少</span><br><span class="line">NormalStruct normal &#x3D; NormalStruct(10, 20, 30);</span><br><span class="line">MiniMe mini &#x3D; MiniMe(10, 20, 30);</span><br></pre></td></tr></table></figure>

<h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><p>Solidity 使用自己的本地时间单位。</p>
<p>变量 <code>now</code> 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 <code>1515527488</code>。</p>
<blockquote>
<p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p>
</blockquote>
<p>Solidity 还包含<code>秒(seconds)</code>，<code>分钟(minutes)</code>，<code>小时(hours)</code>，<code>天(days)</code>，<code>周(weeks)</code> 和 <code>年(years)</code> 等时间单位。它们都会转换成对应的秒数放入 <code>uint</code> 中。所以 <code>1分钟</code> 就是 <code>60</code>，<code>1小时</code>是 <code>3600</code>（60秒×60分钟），<code>1天</code>是<code>86400</code>（24小时×60分钟×60秒），以此类推。</p>
<p>下面是一些使用时间单位的实用案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public &#123;</span><br><span class="line">  lastUpdated &#x3D; now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果到上次&#96;updateTimestamp&#96; 超过5分钟，返回 &#39;true&#39;</span><br><span class="line">&#x2F;&#x2F; 不到5分钟返回 &#39;false&#39;</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) &#123;</span><br><span class="line">  return (now &gt;&#x3D; (lastUpdated + 5 minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>4-僵尸作战系统</title>
    <url>/solidity-course-4-zombie-fighting/</url>
    <content><![CDATA[<p>完成了<a href="https://share.cryptozombies.io/zh/lesson/4/share/NoName?id=W251bGwsMiwxNF0%3D" target="_blank" rel="noopener">第四课</a>！</p>
<h3 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h3><ol>
<li>我们有决定函数何时和被谁调用的可见性修饰符: <code>private</code> 意味着它只能被合约内部调用； <code>internal</code> 就像 <code>private</code> 但是也能被继承的合约调用； <code>external</code> 只能从合约外部调用；最后 <code>public</code> 可以在任何地方调用，不管是内部还是外部。</li>
<li>我们也有状态修饰符， 告诉我们函数如何和区块链交互: <code>view</code> 告诉我们运行这个函数不会更改和保存任何数据； <code>pure</code> 告诉我们这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。这两种在被从合约外部调用的时候都不花费任何gas（但是它们在被内部其他函数调用的时候将会耗费gas）。</li>
<li>然后我们有了自定义的 <code>modifiers</code>，例如在第三课学习的: <code>onlyOwner</code> 和 <code>aboveLevel</code>。 对于这些修饰符我们可以自定义其对函数的约束逻辑。</li>
</ol>
<p>这些修饰符可以同时作用于一个函数定义上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() external view onlyOwner anotherModifier &#123; &#x2F;*</span><br></pre></td></tr></table></figure>

<h3 id="提现"><a href="#提现" class="headerlink" title="提现"></a>提现</h3><p>在上一章，我们学习了如何向合约发送以太，那么在发送之后会发生什么呢？</p>
<p>在你发送以太之后，它将被存储进以合约的以太坊账户中， 并冻结在哪里 —— 除非你添加一个函数来从合约中把以太提现。</p>
<p>你可以写一个函数来从合约中提现以太，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们使用 <code>Ownable</code> 合约中的 <code>owner</code> 和 <code>onlyOwner</code>，假定它已经被引入了。</p>
<p>你可以通过 <code>transfer</code> 函数向一个地址发送以太， 然后 <code>this.balance</code> 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， <code>this.balance</code> 将是100以太。</p>
<p>你可以通过 <code>transfer</code> 向任何以太坊地址付钱。 比如，你可以有一个函数在 <code>msg.sender</code> 超额付款的时候给他们退钱：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint itemFee &#x3D; 0.001 ether;</span><br><span class="line">msg.sender.transfer(msg.value - itemFee);</span><br></pre></td></tr></table></figure>

<p>或者在一个有卖家和卖家的合约中， 你可以把卖家的地址存储起来， 当有人买了它的东西的时候，把买家支付的钱发送给它 <code>seller.transfer(msg.value)</code>。</p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>5-ERC721标准和加密收藏品</title>
    <url>/solidity-course-5-erc721-and-secret-collections/</url>
    <content><![CDATA[<p>第五章<a href="https://share.cryptozombies.io/zh/lesson/5/share/H4XF13LD_MORRIS_%F0%9F%92%AF%F0%9F%92%AF%F0%9F%98%8E%F0%9F%92%AF%F0%9F%92%AF" target="_blank" rel="noopener">完课啦</a>！</p>
<h3 id="ERC721-标准"><a href="#ERC721-标准" class="headerlink" title="ERC721 标准"></a>ERC721 标准</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作就是用一个新合约，继承这个原来的合约，重新实现。</p>
<h3 id="注释和-natspec"><a href="#注释和-natspec" class="headerlink" title="注释和 natspec"></a>注释和 natspec</h3><p>Solidity 社区所使用的一个标准是使用一种被称作 <strong><em>natspec\</em></strong> 的格式，看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @title 一个简单的基础运算合约</span><br><span class="line">&#x2F;&#x2F;&#x2F; @author H4XF13LD MORRIS 💯💯😎💯💯</span><br><span class="line">&#x2F;&#x2F;&#x2F; @notice 现在，这个合约只添加一个乘法</span><br><span class="line">contract Math &#123;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; @notice 两个数相乘</span><br><span class="line">  &#x2F;&#x2F;&#x2F; @param x 第一个 uint</span><br><span class="line">  &#x2F;&#x2F;&#x2F; @param y  第二个 uint</span><br><span class="line">  &#x2F;&#x2F;&#x2F; @return z  (x * y) 的结果</span><br><span class="line">  &#x2F;&#x2F;&#x2F; @dev 现在这个方法不检查溢出</span><br><span class="line">  function multiply(uint x, uint y) returns (uint z) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这只是个普通的注释，不会被 natspec 解释</span><br><span class="line">    z &#x3D; x * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@title</code>（标题） 和 <code>@author</code> （作者）很直接了.</p>
<p><code>@notice</code> （须知）向 <strong>用户</strong> 解释这个方法或者合约是做什么的。 <code>@dev</code> （开发者） 是向开发者解释更多的细节。</p>
<p><code>@param</code> （参数）和 <code>@return</code> （返回） 用来描述这个方法需要传入什么参数以及返回什么值。</p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约简单实战-石头剪刀布</title>
    <url>/smart-contract-rock-scissors-paper/</url>
    <content><![CDATA[<p>在 <code>Ethereum Studio</code> 配置双用户，使用 0.5.10 较新版本的 solidity，实现了 <strong>石头剪刀布</strong> 游戏程序，代码如下。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line"></span><br><span class="line">    mapping (string &#x3D;&gt; mapping(string &#x3D;&gt; int)) payoffMatrix;</span><br><span class="line">    address public player1;</span><br><span class="line">    address public player2;</span><br><span class="line">    string public player1Choice;</span><br><span class="line">    string public player2Choice;</span><br><span class="line">    int public winnerMessage;</span><br><span class="line"></span><br><span class="line">    modifier sentEnoughCash(uint amount) &#123;</span><br><span class="line">        require(msg.value&gt;&#x3D;amount);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    modifier notRegisteredYet()&#123;</span><br><span class="line">        require(msg.sender!&#x3D;player1 &amp;&amp; msg.sender!&#x3D;player2);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        payoffMatrix[&quot;rock&quot;][&quot;rock&quot;] &#x3D; 0;</span><br><span class="line">        payoffMatrix[&quot;rock&quot;][&quot;paper&quot;] &#x3D; 2;</span><br><span class="line">        payoffMatrix[&quot;rock&quot;][&quot;scissors&quot;] &#x3D; 1;</span><br><span class="line">        payoffMatrix[&quot;paper&quot;][&quot;rock&quot;] &#x3D; 1;</span><br><span class="line">        payoffMatrix[&quot;paper&quot;][&quot;paper&quot;] &#x3D; 0;</span><br><span class="line">        payoffMatrix[&quot;paper&quot;][&quot;scissors&quot;] &#x3D; 2;</span><br><span class="line">        payoffMatrix[&quot;scissors&quot;][&quot;rock&quot;] &#x3D; 2;</span><br><span class="line">        payoffMatrix[&quot;scissors&quot;][&quot;paper&quot;] &#x3D; 1;</span><br><span class="line">        payoffMatrix[&quot;scissors&quot;][&quot;scissors&quot;] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getWinner() public view returns(int)&#123;</span><br><span class="line">        return payoffMatrix[player1Choice][player2Choice];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function play(string memory choice) public&#123;</span><br><span class="line">        if(msg.sender&#x3D;&#x3D;player1)&#123;player1Choice&#x3D;choice;&#125;</span><br><span class="line">        else if(msg.sender&#x3D;&#x3D;player2)&#123;player2Choice&#x3D;choice;&#125;</span><br><span class="line">        if(bytes(player1Choice).length !&#x3D; 0 &amp;&amp; bytes(player2Choice).length !&#x3D; 0)&#123;</span><br><span class="line">            winnerMessage&#x3D;payoffMatrix[player1Choice][player2Choice];</span><br><span class="line">            player1Choice&#x3D;&quot;&quot;;</span><br><span class="line">            player2Choice&#x3D;&quot;&quot;;</span><br><span class="line">            player1&#x3D;address(0);</span><br><span class="line">            player2&#x3D;address(0);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    function register() public payable sentEnoughCash(5) notRegisteredYet&#123;</span><br><span class="line"></span><br><span class="line">        if(player1&#x3D;&#x3D;address(0))&#123;player1&#x3D;msg.sender;&#125;</span><br><span class="line">        else if (player2&#x3D;&#x3D;address(0))&#123;player2&#x3D;msg.sender;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>6- 前端和 Web3.js</title>
    <url>/solidity-course-6-front-end-and-web3-js/</url>
    <content><![CDATA[<p><strong>完成了 CryptoZombies 的第六课！</strong> <a href="https://share.cryptozombies.io/zh/lesson/6/share/The_Phantom_of_Web3" target="_blank" rel="noopener">我的僵尸大军</a></p>
<p>以太坊基金发布的 JavaScript 库 —— <strong>Web3.js</strong>.</p>
<p>以太坊节点只能识别一种叫做 <strong>JSON-RPC</strong> 的语言。这种语言直接读起来并不好懂。当你想调用一个合约的方法的时候，需要发送的查询语句将会是这样的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈……祝你写所有这样的函数调用的时候都一次通过</span></span><br><span class="line"><span class="comment">// 往右边拉…… ==&gt;</span></span><br><span class="line">&#123;<span class="attr">"jsonrpc"</span>:<span class="string">"2.0"</span>,<span class="attr">"method"</span>:<span class="string">"eth_sendTransaction"</span>,<span class="attr">"params"</span>:[&#123;<span class="attr">"from"</span>:<span class="string">"0xb60e8dd61c5d32be8058bb8eb970870f07233155"</span>,<span class="attr">"to"</span>:<span class="string">"0xd46e8dd67c5d32be8058bb8eb970870f07244567"</span>,<span class="attr">"gas"</span>:<span class="string">"0x76c0"</span>,<span class="attr">"gasPrice"</span>:<span class="string">"0x9184e72a000"</span>,<span class="attr">"value"</span>:<span class="string">"0x9184e72a"</span>,<span class="attr">"data"</span>:<span class="string">"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"</span>&#125;],<span class="attr">"id"</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>幸运的是 Web3.js 把这些令人讨厌的查询语句都隐藏起来了， 所以你只需要与方便易懂的 JavaScript 界面进行交互即可。</p>
<p>你不需要构建上面的查询语句，在你的代码中调用一个函数看起来将是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">CryptoZombies.methods.createRandomZombie(<span class="string">"Vitalik Nakamoto 🤔 "</span>)</span><br><span class="line">  .send(&#123; <span class="attr">from</span>: <span class="string">"0xb60e8dd61c5d32be8058bb8eb970870f07233155"</span>, <span class="attr">gas</span>: <span class="string">"3000000"</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p><code>call</code> 用来调用 <code>view</code> 和 <code>pure</code> 函数。它只运行在本地节点，不会在区块链上创建事务。</p>
<blockquote>
<p><strong>复习 :</strong> <code>view</code> 和 <code>pure</code> 函数是只读的并不会改变区块链的状态。它们也不会消耗任何 gas。用户也不会被要求用 MetaMask 对事务签名。</p>
</blockquote>
<p>使用 Web3.js，可以如下 <code>call</code> 一个名为 <code>myMethod</code> 的方法并传入一个 <code>123</code> 作为参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myContract.methods.myMethod(123).call()</span><br></pre></td></tr></table></figure>

<h3 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h3><p><code>send</code> 将创建一个事务并改变区块链上的数据。你需要用 <code>send</code> 来调用任何非 <code>view</code> 或者 <code>pure</code> 的函数。</p>
<blockquote>
<p><strong>注意 :</strong> <code>send</code> 一个事务将要求用户支付 gas，并会要求弹出对话框请求用户使用 Metamask 对事务签名。在我们使用 Metamask 作为我们的 web3 提供者的时候，所有这一切都会在我们调用 <code>send()</code> 的时候自动发生。而我们自己无需在代码中操心这一切，挺爽的吧。</p>
</blockquote>
<p>使用 Web3.js, 你可以像这样 <code>send</code> 一个事务调用 <code>myMethod</code> 并传入 <code>123</code> 作为参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myContract.methods.myMethod(123).send()</span><br></pre></td></tr></table></figure>

<p>语法几乎 <code>call()</code> 一模一样。</p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>Solidity Game</tag>
      </tags>
  </entry>
  <entry>
    <title>EMARS: Efficient Management and Allocation of Resources in Serverless-学习笔记</title>
    <url>/emars-efficient-management-and-allocation-of-resource-in-serverless/</url>
    <content><![CDATA[<p><a href="https://ieeexplore.ieee.org/document/8457882" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/8457882</a></p>
<p>关注资源管理，重点关注每个容器的内存使用情况。最终实现的目标是：为每一个容器高效分配内存。</p>
<p>为了高效识别容器的内存状态，定义了4个R效率：①<em>Reduce<em>：根据实际需要限制分配给每个容器的资源②</em>Reuse<em>：使容器保持</em>温暖</em> 状态。③<em>Recycle</em>：仅在长时间不使用它们时才杀死它们。④<em>Refuse</em>：如果系统过载，则不让新容器产生。</p>
<p>基于内存的模型捕获每个功能在一定时间范围内对于内存的需求，然后对于新生成的容器进行内存优化；基于工作量的模型记录每个功能的请求数。综合两个模型的数据，为每个功能生成一个配置文件来限制/分配资源。</p>
<a id="more"></a>

<p>优化思路：使用 LSTM 模型对未来进行内存需要进行预测。</p>
]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Photons: lambdas on a diet-学习笔记</title>
    <url>/photons-lambdas-on-a-diet/</url>
    <content><![CDATA[<p>Serverless 在实际使用过程中有可能会同时调用数百个功能来处理大量并行工作负载。但是其中大部分的占用空间是固定的，即这些Serverless使用的语言运行环境、库是相同的，目前的无服务器计算平台并没有利用这种冗余。直观上这样的低效率系统就带来更长的启动时间和更高的成本。</p>
<p>Photons 是一个由 ETH Zurich 提出的框架，利用工作负载的并行性来在同一运行时内将同一功能的多个实例集成化的框架。</p>
<p>降低内存占用率，降低冷启动总数。</p>
<a id="more"></a>

<h3 id="摘要翻译"><a href="#摘要翻译" class="headerlink" title="摘要翻译"></a>摘要翻译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无服务器计算允许用户创建简短的无状态功能，并同时调用数百个功能来处理大量并行工作负载。我们观察到，即使无服务器功能的大部分占用空间在其调用（语言运行时，库和其他应用程序状态）上都是固定的，但当今的无服务器平台并未利用这种冗余。这种低效率会带来一系列负面影响：更长的启动时间，更低的吞吐量，更高的延迟和更高的成本。为了减轻这些问题，我们构建了Photons，该框架利用工作负载并行性来共同定位同一实例的多个实例。在同一运行时内运行。然后，并发调用可以透明地共享运行时和应用程序状态，而不会影响执行安全性。与当今的无服务器平台相比，光子每次调用可将功能的内存消耗减少25％至98％，并且不会降低性能。我们还表明，我们的方法可以将整体内存利用率降低30％，冷启动总数减少52％。</span><br></pre></td></tr></table></figure>

<h3 id="Photons部分"><a href="#Photons部分" class="headerlink" title="Photons部分"></a>Photons部分</h3><ol>
<li><p>如果工作</p>
<p><img data-src="/photons-lambdas-on-a-diet/image-20201223150728460.png" alt="image-20201223150728460"></p>
</li>
<li><p>如果共享环境</p>
</li>
<li><p>共享状态的识别</p>
</li>
<li><p>避免性能干扰</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Narrowing the Gap Between Serverless and its State with Storage Functions-学习笔记</title>
    <url>/narrowing-the-gap-between-serverless-and-its-state-with-storage-function/</url>
    <content><![CDATA[<p>Serverless 是一种无状态的计算服务，云服务的提供商基于此来实现简化配置和更好的容错。但是这样就需要数据存在远端云存储上，使用”将数据传输到代码中”的方式，引发了大量额外的数据传输的开销。同时传统的云存储系统无法提供相同级别的细粒度资源记帐和按需可伸缩性，反而损害了无服务器模型的优势。</p>
<p>虽然现在有一一些 fast ephemeral 的存储设计能帮助 serverless 应用之间保存需要传递的状态，但是并没有从根本上解决数据传输的问题，同时也没有解决用户想要在已有持久化数据上的计算问题。</p>
<p>本文构建了Shredder，一种低延迟的多租户的云存储系统，允许在存储节点内直接运行计算单元。</p>
<p>为数据密集型计算应用提供巨大的增益。</p>
<p>难点主要是：安全隔离数千个租户的存储功能，同时最大程度减少数据交互的成本。</p>
<h3 id="神经元网络上面的测试"><a href="#神经元网络上面的测试" class="headerlink" title="神经元网络上面的测试"></a>神经元网络上面的测试</h3><p>模型和数据集部署在同一个storage上，然后将 prediction的代码上传上去，减少数据传输。</p>
<p>测试发现 在网络较小的时候，由于 JavaScript计算能力弱于C++，所以性能弱了；但是在网络较大的时候，网络数据传输超过CPU成了主要瓶颈，性能显著上升。</p>
<a id="more"></a>

<p>摘要直接翻译版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无服务器计算由于其细粒度的配置，大规模的多租户和按需缩放而备受关注。但是，这也迫使应用程序将远程存储中的状态外部化，从而增加了大量开销。为了解决此“数据传输问题”，我们构建了Shredder，这是一种低延迟的多租户云存储，它允许在存储节点内直接执行小的计算单元。存储租户为Shredder提供了JavaScript函数（或WebAssembly程序），这些函数可以直接与数据交互，而无需通过网络移动它们。</span><br><span class="line"></span><br><span class="line">Shredder的主要挑战是安全地隔离数千个租户存储功能，同时最大程度地减少数据交互成本。Shredder使用一种独特的方法，即以本机代码实现其数据存储和网络路径以确保性能，而隔离的租户功能则使用V8特定的中间表示与数据进行交互，从而避免了昂贵的跨保护域调用和数据复制。结果，Shredder每秒可以在数以千计的租户中执行400万个远程调用的租户功能，其中位数和第99％的响应延迟分别小于50μs和500μs。我们的评估表明，当获取项目之间仅有一到三个数据相关性的项目时，Shredder与传统的远程存储相比可实现14％至78％的加速。</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Truffle快速入门</title>
    <url>/truffle-get-started/</url>
    <content><![CDATA[<h1 id="Truffle简介"><a href="#Truffle简介" class="headerlink" title="Truffle简介"></a>Truffle简介</h1><p>Truffle 是一个世界级的开发环境，测试框架，以太坊的资源管理通道，致力于让以太坊上的开发变得简单，Truffle 有以下特点：</p>
<ul>
<li>内置的智能合约编译，链接，部署和二进制文件的管理。</li>
<li>快速开发下的自动合约测试。</li>
<li>脚本化的，可扩展的部署与发布框架。</li>
<li>部署到不管多少的公网或私网的网络环境管理功能</li>
<li>使用EthPM&amp;NPM提供的包管理，使用<a href="https://github.com/ethereum/EIPs/issues/190" target="_blank" rel="noopener">ERC190</a>标准。</li>
<li>与合约直接通信的直接交互控制台（写完合约就可以命令行里验证了）。</li>
<li>可配的构建流程，支持紧密集成。</li>
<li>在Truffle环境里支持执行外部的脚本。</li>
</ul>
<h3 id="Truffle-框架安装"><a href="#Truffle-框架安装" class="headerlink" title="Truffle 框架安装"></a>Truffle 框架安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure>

<p><strong>Windows用户的建议</strong></p>
<p>推荐使用 Powershell 或 Git BASH 来安装和使用Truffle框架。这两个 shell 环境相对默认的，提供了更方便的一些特性。</p>
<h3 id="Truffle-客户端"><a href="#Truffle-客户端" class="headerlink" title="Truffle 客户端"></a>Truffle 客户端</h3><p>使用 Ganache 的桌面客户端 <del>我使用官网推荐的 Test RPC <code>is now</code> <a href="https://github.com/trufflesuite/ganache-cli" target="_blank" rel="noopener">ganache-cli</a></del> </p>
<blockquote>
<p>当开发基于Truffle的应用时，我们推荐使用EthereumJS TestRPC。它是一个完整的在内存中的区块链仅仅存在于你开发的设备上。它在执行交易时是实时返回，而不等待默认的出块时间，这样你可以快速验证你新写的代码，当出现错误时，也能即时反馈给你。它同时还是一个支持自动化测试的功能强大的客户端。Truffle充分利用它的特性，能将测试运行时间提速近90%。</p>
</blockquote>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle init</span><br></pre></td></tr></table></figure>

<h3 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h3><p>所有的合约应该位于 <code>./contracts</code> 目录。默认我们提供了一个合约文件，一个库文件，均以 <code>.sol</code> 结尾作为示例。尽管库文件有一定的特殊性，但为简单起见，当前均称之为合约。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle compile</span><br></pre></td></tr></table></figure>

<p>Truffle 仅默认编译自上次编译后被修改过的文件，来减少不必要的编译。如果你想编译全部文件，可以使用 <code>--compile-all</code> 选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">truffle compile --compile-all</span><br></pre></td></tr></table></figure>

<p><strong>编译目录</strong></p>
<p>编译的输出位于 <code>./build/contracts</code> 目录。如果目录不存在会自动创建。这些编译文件对于Truffle框架能否正常工作至关重要。不应该在正常的编译或发布以外手动修改这些文件。</p>
<h3 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h3><p>移植是由一些 Javascript 文件组成来协助发布到以太坊网络。主要目的是用来缓存你的发布任务，它的存在基于发布需求会改变的前提。当工程发生了重要的改变，将创建新的移植脚本来将这些变化带到区块链上。</p>
<p><strong>待续…不过感觉没啥内容了</strong></p>
]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
  </entry>
  <entry>
    <title>Serverless Computing - Current Trends and Open Problems 学习笔记</title>
    <url>/serverless-computing-current-trends-and-open-problems/</url>
    <content><![CDATA[<p>很早的文章，侧重于定义概念，引出问题。</p>
<a id="more"></a>

<h2 id="阅读的时候同步的笔记："><a href="#阅读的时候同步的笔记：" class="headerlink" title="阅读的时候同步的笔记："></a>阅读的时候同步的笔记：</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li><p>从云提供商的角度来看，无服务器计算提供了额外的机会来控制整个开发堆栈，通过有效地优化和管理云资源来降低运营成本，提供了鼓励在其生态系统中使用附加服务的平台，并降低了编写和管理云规模应用程序所需的工作。</p>
<blockquote>
<p>From the perspective of a cloud provider, serverless computing provides an additional opportunity to control the entire development stack, reduce operational costs by efficient optimization and management of cloud resources, offer a platform that encourages the use of additional services in their ecosystem, and lower the effort required to author and manage cloud-scale applications.</p>
</blockquote>
</li>
<li><p>无服务器计算是一种编程模型和体系结构，在这种模型和体系结构中，小代码段在云中执行，而对代码运行的资源没有任何控制。但这并不代表没有服务器，只是开发人员应将大部分运营问题（如资源供应，监视，维护，可伸缩性和容错性）留给云提供商。</p>
</li>
<li><p>定义：考虑开发人员对云基础架构的不同控制级别。</p>
<p><img data-src="/serverless-computing-current-trends-and-open-problems/image-20201220155819315.png" alt="image-20201220155819315"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Wukong: a scalable and locality-enhanced framework for serverless parallel computing-学习笔记</title>
    <url>/wukong-a-scalable-and-locality-enhanced-framework-for-severless-parallel-computing/</url>
    <content><![CDATA[<h1 id="悟空"><a href="#悟空" class="headerlink" title="悟空"></a>悟空</h1><h1 id="无服务器并行计算的可扩展性和本地性增强框架"><a href="#无服务器并行计算的可扩展性和本地性增强框架" class="headerlink" title="无服务器并行计算的可扩展性和本地性增强框架"></a>无服务器并行计算的可扩展性和本地性增强框架</h1><p>无框架执行框架需要以高吞吐量快速扩展和调度任务，同时最大程度地减少跨任务的数据移动。</p>
<p>【数据局部性增强】</p>
<p>近来的趋势是将无服务器计算用于更复杂，有状态的并行应用程序。</p>
<a id="more"></a>

<p>摘要翻译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于无服务器执行框架而言，执行复杂的，突发并行，有向无环图（DAG）作业提出了一项重大挑战，无框架执行框架需要以高吞吐量快速扩展和调度任务，同时最大程度地减少跨任务的数据移动。我们证明了，对于无服务器并行计算，分散式调度使调度能够在可以并行调度任务的Lambda执行器之间进行分配，并带来多种好处，包括增强的数据局部性，减少的网络I &#x2F; O，自动的资源弹性以及提高的成本效益。 。我们描述了在AWS Lambda上新的无服务器并行框架（称为Wukong）的实现和部署。我们展示了悟空实现了近乎理想的可扩展性，更快地执行了高达68.17倍的并行计算作业，将网络I &#x2F; O降低了多个数量级</span><br></pre></td></tr></table></figure>

<p>传统上，调度程序具有各种目标，包括负载平衡，最大程度地利用群集，确保任务公平性等。</p>
<p>但是，无服务器计算不需要传统的服务器式调度程序。因为：（1）FaaS提供者负责管理“服务器”（即任务执行者所在的主机）； （2）无服务器平台通常提供几乎无限量的临时资源。</p>
<p>然而，设计一种高效的面向无服务器的并行计算框架会带来独特的挑战。首先，虽然无服务器平台（例如AWS Lambda）承诺提供出色的弹性和自动扩展属性，但无服务器调用模型会带来不小的调度开销。</p>
<p>任务调度三种方法：1对1；1对多；调度程序将任务放在共享的工作队列中。</p>
<p>Wukong是一个面向无服务器，分散，本地化且具有成本效益的并行计算框架。 </p>
<p>Wukong的关键见解在于，将集中式调度程序的工作（即跟踪任务完成，识别和分派就绪任务等）分配给大量Lambda执行器，可以通过允许并行调度任务来极大地提高性能。</p>
<p>通过将DAG划分为多个可能重叠的子图，可以分散调度。每个子图都分配给一个任务执行器（实现为AWS Lambda函数运行时），该任务执行器负责在其分配的子图中调度和执行任务。</p>
<ol>
<li>增强了数据局部性并减少了资源争用</li>
<li>利用规模和本地优化机会</li>
<li>自动的资源弹性和更高的成本效益</li>
</ol>
<p>We make the following contributions in this paper.</p>
]]></content>
  </entry>
  <entry>
    <title>Particle - Ephemeral Endpoints for Serverless-学习笔记</title>
    <url>/particle-ephemeral-endpoints-for-severles/</url>
    <content><![CDATA[<p>尽管并行无服务器的任务在几秒钟内就能执行完，但是启动和配置它们所依赖的虚拟网络是一个主要瓶颈，可能会占用多达84％的启动时间。</p>
<p>在本文中，我们用Docker Swarm，Weave和Linux Overlay这三个流行的覆盖网络来描述此<em>网络冷启动</em>问题的严重性。我们专注于端到端启动时间既包括启动一组容器以及将它们互连的时间。</p>
<p>我们的主要观察结果是，现有的无服务器网络覆盖方法在短暂的无服务器环境中扩展性很差。</p>
<p>根据我们的发现，我们开发了为多节点无服务器覆盖网络量身定制的网络堆栈Particle，可在不牺牲多租户，通用性或吞吐量的情况下优化网络创建。</p>
<p>当集成到无服务器突发并行视频处理管道中时，Particle可以将应用程序运行时间比现有的覆盖层提高2.4–3倍。</p>
<a id="more"></a>

<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>本文主要的贡献：</p>
<ol>
<li>An evaluation of the challenges of serverless burstparallel<br>networking with a focus on the network startup<br>problem.</li>
<li>An evaluation of three different designs to overcome<br>network startup issues.</li>
<li>A final design, Particle, that enables constant time network<br>creation and startup. We evaluate Particle with<br>microbenchmarks, serverless patterns, burst-parallel<br>applications, multi-tenant settings, and verify no adverse<br>effects on network throughput.</li>
</ol>
<h3 id="Background-and-Motivation"><a href="#Background-and-Motivation" class="headerlink" title="Background and Motivation"></a>Background and Motivation</h3><p>应对突发性的能力（container startup time）越来越重要。</p>
<p>从 现有覆盖网络中节点数量和单个节点的连接数两个角度进行了测试。</p>
<ol>
<li><p>影响不大？</p>
</li>
<li><p>重点放在了分析网络名称空间的分析上，而不是容器创造的时间。</p>
<p>随着网络名称空间数量的增加，设置的代价也随之增加。缺乏可伸缩性是无服务器上突发并行部署的主要瓶颈。</p>
</li>
</ol>
<h3 id="Particle-Design"><a href="#Particle-Design" class="headerlink" title="Particle Design"></a>Particle Design</h3><p>Particle 在几乎恒定的启动时间提供了短暂动态生成的IP池。<br>Particle并没有使用内存密集型缓存技术，而是首先将网络创建与其他用户名称空间分离开来创建网络端点组，然后通过消除序列化点，批处理调用和合并VETH设备来优化网络端点的创建，同时保持每个功能的IP。</p>
<p>这样，Particle可以加速网络名称空间的创建，而不会对应用程序的功能或通用性产生任何不利影响。</p>
<p>实现了一下三点的功能：</p>
<ol>
<li><p>Match Infrastructure to Application</p>
</li>
<li><p>Generic Socket Interface</p>
<p>Particle 分配了IP的容器可以实现相互通信，而无需任何专门的IPC协议</p>
</li>
<li><p>Portability</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Serving Deep Learning Models in a Serverless Platform 学习笔记</title>
    <url>/serving-deep-learning-models-in-a-Serverless-platform/</url>
    <content><![CDATA[<p>2018 IEEE 11th International Conference on Cloud Computing</p>
<p>侧重于在 Serverless Platform 上进行神经网络推理 的 评估。</p>
<p>评估着眼于 冷/温启动时间、和内存大小相关的性能、cost等。</p>
<a id="more"></a>

<h3 id="文章结论部分"><a href="#文章结论部分" class="headerlink" title="文章结论部分"></a>文章结论部分</h3><blockquote>
<p>Our results indicate that warm serverless function executions are within an acceptable latency range, while cold starts add significant overhead.</p>
</blockquote>
<h3 id="阅读的时候同步的笔记："><a href="#阅读的时候同步的笔记：" class="headerlink" title="阅读的时候同步的笔记："></a>阅读的时候同步的笔记：</h3><ol>
<li>related work 不错</li>
<li>启动时间 - cold / warm</li>
</ol>
]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Serverless Data Analytics with Flint-学习笔记</title>
    <url>/serverless-data-analytics-with-flint/</url>
    <content><![CDATA[<p>研究 使用无服务器架构对大数据进行分析处理的可行性</p>
<p>Flint 是 Spark 原型执行引擎，利用AWS Lambda提供了一个纯粹的即付即用成本模型。</p>
<a id="more"></a>

<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>无服务器部署的特点是异步、松耦合和事件驱动。<strong>这些过程仅接触相对较少的数据</strong></p>
<p>常见的应用场景：上传图片到 S3，然后触发Lambda生成缩略图。然后Lambda将消息放到队列中，进而可以触发后续的进一步操作。</p>
<p>本文针对针对完全不同的用例探索了无服务器架构：<strong>数据科学家进行的大规模分析数据处理</strong>。</p>
<p>证明了确实有可能使用无服务器架构来构建分析数据处理框架。</p>
<h3 id="BACKGROUND-AND-DESIGN-GOALS"><a href="#BACKGROUND-AND-DESIGN-GOALS" class="headerlink" title="BACKGROUND AND DESIGN GOALS"></a>BACKGROUND AND DESIGN GOALS</h3><p>Flint的一个主要设计目标是提供一种真正的按需购买的成本模型，而没有闲置容量的成本。</p>
<ul>
<li>相对应：Amazon Relational Database Service（RDS）要求用户为数据库实例付费（每小时）。这<em>不是</em>一劳永逸的费用，因为即使系统处于空闲状态，也会产生持续的成本。</li>
</ul>
<h3 id="FLINT-ARCHITECTURE"><a href="#FLINT-ARCHITECTURE" class="headerlink" title="FLINT ARCHITECTURE"></a>FLINT ARCHITECTURE</h3><p><img data-src="/serverless-data-analytics-with-flint/8457831-fig-1-source-large.gif" alt="img"></p>
<p>Spark任务在较高级别的AWS Lambda中执行，中间数据在Amazon的Simple Queue Service（SQS）中保存，该服务处理实现许多转换所需的数据改组。</p>
<p><strong>Flint会重用尽可能多的现有Spark组件。</strong></p>
<p>初始化Flint执行程序后，它将首先从请求参数反序列化任务信息。执行器从输入分区元数据中创建一个输入迭代器，以从适当的输入分区中读取。对于计划的第一阶段，此迭代器将从S3对象获取一定范围的字节。对于大多数其他阶段，输入迭代器将从指定的SQS队列中获取（下面详细讨论）。</p>
<p>输入迭代器准备就绪后，会将其作为参数从任务传递给dese-rialized函数（即要执行的代码）；这产生输出迭代器。如果任务处于执行计划的最后（结果）阶段，则有两种可能性：如果对RDD的最终操作是saveAsTextFile，则将输出具体化到另一个S3存储桶；否则，可能会失败。否则，结果将在执行程序中具体化并传递回调度程序（例如，如果数据科学家调用了收集操作）。</p>
<p>当任务是中间阶段的一部分时，执行计划要求将输出进行混洗，以便将键的所有值都放在同一分区中。改组是Spark制定的物理计划的一部分；Flint执行器仅执行任务，因此没有明确知道实际的RDD转换（例如，如果改组是reduceByKey或join的一部分，等等）。由于Lambda调用的执行时间限制为300秒，因此无法保证前一阶段的Flint执行程序仍然有效，无法将数据传递给下一阶段运行任务的执行程序。因此，我们需要一些外部数据存储来传递中间输出。Flint为此使用Amazon的简单队列服务（SQS）。</p>
<p>一旦属于中间阶段的任务的执行者计算了输出迭代器，则使用哈希分区函数（或自定义分区函数，如果指定）来确定每个输出对象将分配到哪个分区。执行程序按内存中的目标分区对对象进行分组。但是，如果在此过程中内存使用率变得过高，则执行程序将通过创建一批SQS消息并将其发送到每个分区的适当队列，来刷新其内存中的缓冲区。将所有输出数据发送到SQS队列后，执行程序终止并返回包含各种诊断信息（例如，消息数，SQS调用等）的响应。</p>
<p>一旦完成当前阶段的所有任务，将启动下一阶段任务的执行程序。这些执行程序从其相应的SQS队列中读取并聚合内存中的数据。如前所述，结果将传递到与任务关联的函数的迭代器。由于我们使用内存中的数据结构进行聚合，因此内存形成了瓶颈。由于在Lambda环境中实现磁盘多遍聚合算法的复杂性，我们目前通过增加分区数来解决此问题，以免内存溢出。该解决方案似乎很合适，因为它利用了AWS Lambda提供的弹性。</p>
<p>队列管理由调度程序执行。在执行每个阶段之前，调度程序将初始化必要的分区。分区元数据（即源队列和目标队列）作为Lambda请求的一部分传递。调度程序还处理清理。</p>
]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Exploring Serverless Computing for Neural Network Training 学习笔记</title>
    <url>/exploring-serverless-computing-for-neural-network-training/</url>
    <content><![CDATA[<p>2018 IEEE 11th International Conference on Cloud Computing</p>
<a id="more"></a>

<h3 id="阅读的时候同步的笔记："><a href="#阅读的时候同步的笔记：" class="headerlink" title="阅读的时候同步的笔记："></a>阅读的时候同步的笔记：</h3><ol>
<li>关注参考文献</li>
<li>关注 intro 部分的贡献</li>
<li>从分布式深度学习到Serverless</li>
<li>分层的想法来进行传输</li>
<li>数据传输的问题</li>
<li>深度学习的并行计算问题</li>
</ol>
]]></content>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
</search>
